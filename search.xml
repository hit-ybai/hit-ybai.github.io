<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[人类误判心理（3）]]></title>
      <url>/2016/05/18/2016-05-18-charlie-munger-on-the-psychology-of-human-misjudgment-three/</url>
      <content type="html"><![CDATA[<p>作者：查理·芒格</p>
<h3 id="Third-incentive-cause-bias-both-in-one’s-own-mind-and-that-of-ones-trusted-advisor-where-it-creates-what-economists-call-‘agency-costs-’"><a href="#Third-incentive-cause-bias-both-in-one’s-own-mind-and-that-of-ones-trusted-advisor-where-it-creates-what-economists-call-‘agency-costs-’" class="headerlink" title="Third: incentive-cause bias, both in one’s own mind and that of ones trusted advisor, where it creates what economists call ‘agency costs.’"></a>Third: incentive-cause bias, both in one’s own mind and that of ones trusted advisor, where it creates what economists call ‘agency costs.’</h3><p><strong>第三条：由激励导致的偏见，同时存在于每个人和其所信赖的顾问的脑海中，它造就了经济学家所谓的「代理成本」（agency costs）</strong></p>
<p><em>Here, my early experience was a doctor who sent bushel baskets full of normal gall bladders down to the pathology lab in the leading hospital in Lincoln, Nebraska. And with that quality control for which community hospitals are famous, about five years after he should’ve been removed from the staff, he was. And one of the old doctors who participated in the removal was also a family friend, and I asked him: I said, “Tell me, did he think, ‘Here’s a way for me to exercise my talents’” – this guy was very skilled technically– “’and make a high living by doing a few maimings and murders every year, along with some frauds?’” And he said, “Hell no, Charlie. He thought that the gall bladder was the source of all medical evil, and if you really love your patients, you couldn’t get that organ out rapidly enough.”</em></p>
<p>之前在 Lincoln, Nebraska 的一家顶级医院中，有一名医生经常提着装了一篮子「一切正常」的胆囊到病理学实验室，五年之后，他被这家以质量闻名的社区医院开除了。</p>
<p>有一位当时参与了做出开除决定的老医生，是家里的朋友。我问他:『是不是这人觉得自己技术不错，通过致残、杀害和欺诈一些人，来施展自己的「才华」，过上土豪的生活？』。</p>
<p>老医生回答说：「当然不是，他认为胆囊是医疗隐患，如果你真的爱你的病人，就要用最快的速度把这个它从他体内取出。」</p>
<p><em>未完待续</em></p>
]]></content>
      
        <categories>
            
            <category> 读书报告 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 读书报告 </tag>
            
            <tag> 心理 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[软件工程师的核心价值]]></title>
      <url>/2015/11/13/2015-11-13-the-core-value-of-sde/</url>
      <content type="html"><![CDATA[<h2 id="高效完成产品需求"><a href="#高效完成产品需求" class="headerlink" title="高效完成产品需求"></a>高效完成产品需求</h2><p>用最少的时间完成PM的需求，<strong>用更多的时间去接触新技术，制造（学习）工具，提高效率，享受生活</strong>。</p>
<h2 id="提取工作重复部分-DRY"><a href="#提取工作重复部分-DRY" class="headerlink" title="提取工作重复部分 (DRY)"></a>提取工作重复部分 (DRY)</h2><p>提取工作中的重复部分，独立维护。写的代码越多，需要维护的代码就越多，所以要尽量减少代码冗余（据嗣彬同学说，邓公在FW内部培训的时候也表达过类似的观点）。<br><img src="http://7xjra1.com1.z0.glb.clouddn.com/more_code_more_error.jpg" alt="Code and Error"></p>
<h2 id="将系统抽象成模型"><a href="#将系统抽象成模型" class="headerlink" title="将系统抽象成模型"></a>将系统抽象成模型</h2><p>把复杂的东西讲得简单，难的东西讲得容易，让他人和未来的自己能流畅地了解一个系统。</p>
<h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><p><em><a href="http://www.cppblog.com/vczh/archive/2014/07/15/207658.html" target="_blank" rel="external">靠谱的代码和DRY</a></em></p>
]]></content>
      
        <categories>
            
            <category> 程序开发 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[B-Tree]]></title>
      <url>/2015/10/15/2015-10-15-b-tree/</url>
      <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>如果一个内部节点 <em>X</em> 包含了 <em>n</em> 个有序关键字，那么节点 <em>X</em> 有 <em>n + 1</em> 个子节点，每个叶节点有相同的深度即树的高度。</p>
<p>节点 <em>X</em> 由其关键字分隔为 <em>n + 1</em> 个子域，每个子域和一个子树相对应。在对一个关键字进行搜索时，会通过比较节点中关键字，进行 <em>n + 1</em> 路选择遍历查找。</p>
<p><img src="http://7xjra1.com1.z0.glb.clouddn.com/b-tree.png" alt="B-Tree"></p>
<p>节点中关键字的个数存在上下界，用<code>B-Tree</code>的最小度数 <em>t &gt;= 2</em> 来表示。非根节点至少有 <em>t - 1</em> 个关键字，即有 <em>t</em> 棵子树；至多有 <em>2t - 1</em> 个关键字，即有 <em>2t</em> 棵子树，这时我们称这个节点是满的。当 <em>t = 2</em> 时，每个内部节点有 2 个、 3 个或 4 个子树，即一棵 <em>2-3-4 树</em>。</p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="B-TREE-SEARCH"><a href="#B-TREE-SEARCH" class="headerlink" title="B-TREE-SEARCH"></a>B-TREE-SEARCH</h3><p><code>class BTree</code><br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(key)</span></span></div><div class="line">  b_tree_search(@root, key)</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">b_tree_search</span><span class="params">(node = <span class="literal">nil</span>, search_key)</span></span></div><div class="line">  <span class="keyword">return</span> <span class="literal">nil</span> <span class="keyword">unless</span> node</div><div class="line">  node.keys.each_with_index <span class="keyword">do</span> <span class="params">|key, idx|</span></div><div class="line">    <span class="keyword">return</span> [node, idx] <span class="keyword">if</span> search_key == key</div><div class="line">    <span class="keyword">next</span> <span class="keyword">if</span> search_key &gt; key</div><div class="line">    b_tree_search(node.child[idx], key)</div><div class="line">    <span class="keyword">break</span></div><div class="line">  <span class="keyword">end</span></div><div class="line">  b_tree_search(node.child.last, key)</div><div class="line">  <span class="literal">nil</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></p>
<h3 id="B-TREE-CREATE"><a href="#B-TREE-CREATE" class="headerlink" title="B-TREE-CREATE"></a>B-TREE-CREATE</h3><p><code>class Node</code><br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialize</span></span></div><div class="line">  @leaf  = <span class="literal">true</span></div><div class="line">  @keys  = []</div><div class="line">  @child = []</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></p>
<p><code>class BTree</code><br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialize</span></span></div><div class="line">  @root = Node.new</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></p>
<h3 id="插入关键字"><a href="#插入关键字" class="headerlink" title="插入关键字"></a>插入关键字</h3><p>我们无法直接新建一个叶节点，把关键字插入其中（这样的<code>B-Tree</code>可能是不合法的），所以我们会把新的关键字插入到已有的节点中。不过这样可能会导致一个节点关键字的数量超过它的上界，所以我们引入一个新的操作：分裂<code>B-Tree</code>中的节点。</p>
<h3 id="B-TREE-SPLIT-CHILD"><a href="#B-TREE-SPLIT-CHILD" class="headerlink" title="B-TREE-SPLIT-CHILD"></a>B-TREE-SPLIT-CHILD</h3><p><img src="http://7xjra1.com1.z0.glb.clouddn.com/b-tree-split-child.png" alt="B-TREE-SPLIT-CHILD"><br><code>class BTree</code><br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">b_tree_split_node</span><span class="params">(node, pos)</span></span></div><div class="line">  new_child = Node.new</div><div class="line">  old_child = node.child[pos]</div><div class="line"></div><div class="line">  new_child.leaf  = old_child.leaf</div><div class="line">  new_child.keys  = old_child.pop(@t - <span class="number">1</span>)</div><div class="line">  new_child.child = old_child.pop(@t)</div><div class="line"></div><div class="line">  node.insert_child( new_child, pos + <span class="number">1</span> )</div><div class="line">  node.insert_key( old_child.keys.pop, pos )</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 程序开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> data structure </tag>
            
            <tag> tree </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[Rails] 从Request到Response（2）]]></title>
      <url>/2015/06/28/2015-06-26-rails-request-to-response-two/</url>
      <content type="html"><![CDATA[<p><em>本文翻译自：<a href="http://andrewberls.com/blog/post/rails-from-request-to-response-part-2--routing" target="_blank" rel="external">Rails from Request to Response 系列</a>；个人选择了自己感兴趣的部分进行翻译，需要阅读原文的同学请戳前面的链接。</em></p>
<h2 id="第二部分-路由（Routing）"><a href="#第二部分-路由（Routing）" class="headerlink" title="第二部分 路由（Routing）"></a>第二部分 路由（Routing）</h2><p>Blog::Application.routes 的定义也在 engine.rb 文件中：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># rails/railties/lib/rails/engine.rb</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">routes</span></span></div><div class="line">  @routes <span class="params">||</span>= ActionDispatch::Routing::RouteSet.new</div><div class="line">  @routes.append(&amp;Proc.new) <span class="keyword">if</span> block_given?</div><div class="line">  @routes</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></p>
<p>Blog::Application.routes 会返回一个 ActionDispatch::Routing::RouteSet 的实例。这是我们第一次接触到 ActionDispatch 模块（module），它是 ActionPack 的一部分。</p>
<p>ActionDispatch ：<br>负责处理例如「路由（Routing）」，「参数解析（Parameter Parsing）」，「Cookies」和「Sessions」之类的工作；</p>
<p>ActionPack ：<br>Rails 源码的顶层的 gem 之一，功能包括：路由功能， controller （ActionController）的定义和 view （ActionView）的渲染；</p>
<p>RouteSet ：<br>此类是一个Route的集合，包括一个 route 的数组（Mapper），和一个 named route （NamedRouteCollection： name 对应着一组普通的 route 集合的Hash）。负责解释和分派请求（Request）到对应的控制器（Controller）动作（Action）。</p>
<p>现在继续来看 engine ，回到 RouteSet 的 #call 方法，相关的代码在 <em>actionpack/lib/action_dispatch/routing/route_set.rb</em> 中：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># rails/actionpack/lib/action_dispatch/routing/route_set.rb</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">module</span> <span class="title">ActionDispatch</span></span></div><div class="line">  <span class="class"><span class="keyword">module</span> <span class="title">Routing</span></span></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">RouteSet</span></span></div><div class="line"></div><div class="line">      <span class="function"><span class="keyword">def</span> <span class="title">call</span><span class="params">(env)</span></span></div><div class="line">        @router.call(env)</div><div class="line">      <span class="keyword">end</span></div><div class="line"></div><div class="line">      ...</div><div class="line"></div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></p>
<p>RouteSet 不会处理 @router 里的事情。如果我们看一下 <a href="https://github.com/rails/rails/blob/0dea33f770305f32ed7476f520f7c1ff17434fdc/actionpack/lib/action_dispatch/routing/route_set.rb#L299" target="_blank" rel="external">RouteSet constructor</a>，会发现 @router 其实是 Journey::Router 的一个实例。</p>
<h3 id="Journey"><a href="#Journey" class="headerlink" title="Journey"></a>Journey</h3><p>Journey 是 ActionDispatch 的核心路由模块。它的<a href="https://github.com/rails/rails/tree/0dea33f770305f32ed7476f520f7c1ff17434fdc/actionpack/lib/action_dispatch/journey" target="_blank" rel="external">代码</a>是非常有趣的，其中用到了广义状态转移图（generalized transition graph）和非确定性有限状态自动机（non-deterministic finite automata）来配对URLs和路由。</p>
<p>有兴趣的话可以拿出你的计算机科学与技术本科的教科书（译注：指的应是《形式语言与自动机》）复习一下！Journey 甚至还包含了一个完整的 <a href="https://github.com/rails/rails/blob/0dea33f770305f32ed7476f520f7c1ff17434fdc/actionpack/lib/action_dispatch/journey/parser.y" target="_blank" rel="external">yacc 语法文件</a>来对 routes 进行语法分析。</p>
<p>Journey::Router 的 #call 方法有些长，下面是相关部分：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># rails/actionpack/lib/action_dispatch/journey/router.rb</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">module</span> <span class="title">ActionDispatch</span></span></div><div class="line">  <span class="class"><span class="keyword">module</span> <span class="title">Journey</span></span></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Router</span></span></div><div class="line"></div><div class="line">      <span class="function"><span class="keyword">def</span> <span class="title">call</span><span class="params">(env)</span></span></div><div class="line">        find_routes(env).each <span class="keyword">do</span> <span class="params">|match, parameters, route|</span></div><div class="line">          env[@params_key] = (set_params <span class="params">||</span> &#123;&#125;).merge parameters</div><div class="line">          status, headers, body = route.app.call(env)</div><div class="line">          <span class="keyword">return</span> [status, headers, body]</div><div class="line">        <span class="keyword">end</span></div><div class="line">      <span class="keyword">end</span></div><div class="line"></div><div class="line">      ...</div><div class="line"></div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></p>
<p>我们看到了和 Unicorn 中 #process_client 一样的 Rack 接口。 #find_routes 通过路由表 GTG (generalized transition graph) simulator 对URL进行执行。路由表本身是由 config/routes.rb 中规定的路由信息，构造的一个 Journey::Routes 实例，它包含了全部的路由（多个 Journey::Route 实例），个人十分推荐通过 <em>RailsCasts</em> <a href="http://railscasts.com/episodes/231-routing-walkthrough" target="_blank" rel="external">#231</a>和<a href="http://railscasts.com/episodes/232-routing-walkthrough-part-2" target="_blank" rel="external">#232</a>来学习路由结构的更多细节。</p>
<p>倘若发现了匹配的路由，我们便调用与 route 相关联的 app 上的 #call 方法。只要我们现在在 Rails 源码中看到引用 app 的地方，就可以假定它是 Rack app 。其实每个 controller 中 action 的行为都和一个 Rack app 一样。与 route 相关联的 app 的初始化过程有一些 Tricky。</p>
<p>在构造路由表时， ActionDispatch::Routing::Mapper 类调用 add_route ，它将会构造 Journey::Route 的一个实例，与 controller endpoint  ——  the Rack app 相关联。</p>
<p>然而，在  mapper.rb  中这个类的定义有将近 2,000 行，以下是删减版的 Mapper#add_route 定义：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># rails/actionpack/lib/action_dispatch/routing/mapper.rb</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">module</span> <span class="title">ActionDispatch</span></span></div><div class="line">  <span class="class"><span class="keyword">module</span> <span class="title">Routing</span></span></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Mapper</span></span></div><div class="line"></div><div class="line">      <span class="function"><span class="keyword">def</span> <span class="title">add_route</span><span class="params">(action, options)</span></span></div><div class="line">        path = path_for_action(action, options.delete(<span class="symbol">:path</span>))</div><div class="line"></div><div class="line">        ...</div><div class="line"></div><div class="line">        mapping = Mapping.new(@set, @scope, URI.parser.escape(path), options)</div><div class="line">        app, conditions, requirements, defaults, as, anchor = mapping.to_route</div><div class="line">        @set.add_route(app, conditions, requirements, defaults, as, anchor)</div><div class="line">      <span class="keyword">end</span></div><div class="line"></div><div class="line">      ...</div><div class="line"></div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></p>
<p>在这里， @set 是我们之前提到的 RouteSet ，这里的 app 其实是 ActionDispatch::Routing::Dispatcher 的一个实例。 Dispatcher 类定义在 route_set.rb 中，这是 #call 的一个简单定义。</p>
<p>为了说的更清楚，想象一下我们正在通过URL /posts 访问我们的博客应用，它的路由指向了 Posts Controller 的 index 方法。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># rails/actionpack/lib/action_dispatch/routing/route_set.rb</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">module</span> <span class="title">ActionDispatch</span></span></div><div class="line">  <span class="class"><span class="keyword">module</span> <span class="title">Routing</span></span></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Dispatcher</span></span></div><div class="line"></div><div class="line">      <span class="function"><span class="keyword">def</span> <span class="title">call</span><span class="params">(env)</span></span></div><div class="line">        params = env[PARAMETERS_KEY]</div><div class="line">        prepare_params!(params) </div><div class="line">        <span class="comment"># params = &#123;:action=&gt;"index", :controller=&gt;"posts"&#125;</span></div><div class="line"></div><div class="line">        controller = controller(params, @defaults.key?(<span class="symbol">:controller</span>))</div><div class="line">        <span class="comment"># controller = PostsController</span></div><div class="line"></div><div class="line">        dispatch(controller, params[<span class="symbol">:action</span>], env)</div><div class="line">      <span class="keyword">end</span></div><div class="line"></div><div class="line">      ...</div><div class="line"></div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>在这里， controller 方法已经解析了控制器参数（比如 posts ），并且给了我们一个类（PostsController）的引用，得到了基本的参数哈希（params hash）。</p>
<p>现在，已经准备好了去调用控制器（controller）上的方法（aciton），来得到完整的响应（response）。以下是 dispatch 方法的定义：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># rails/actionpack/lib/action_dispatch/routing/route_set.rb</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">dispatch</span><span class="params">(controller, action, env)</span></span></div><div class="line">  controller.action(action).call(env)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>到这里，我们成功地将 route 映射到了一个 controller/action ，作为下一个 post 处理的请求（request）被压入ActionController工作栈。</p>
<p>路由是 Rails 中一个相当复杂的一个部分，他的方法链很长。像之前所说的，我们并没有必要了解它的全部细节。Rails 具有魔力的地方就是它为你隐藏了所有这些细节。当然去探索这整个执行过程到底是如何发生的是一件很有趣的事情。</p>
<h3 id="译者总结："><a href="#译者总结：" class="headerlink" title="译者总结："></a>译者总结：</h3><p>实际上每个存在的 Controller 和 Action 的组合都是一个 Rack App ，假设它们存在于一个集合 rack_app_set 中；同时假设所有系统可接受的合法URL的集合为 URL_set 。</p>
<p>则路由为函数：</p>
<blockquote>
<p>ƒ: <em>URL_set</em> → <em>rack_app_set</em></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 程序开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> rails </tag>
            
            <tag> 学习报告 </tag>
            
            <tag> dispatcher </tag>
            
            <tag> route </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[Rails] 从Request到Response（1）]]></title>
      <url>/2015/06/26/2015-06-26-rails-request-to-response-one/</url>
      <content type="html"><![CDATA[<p><em>本文翻译自：<a href="http://andrewberls.com/blog/post/rails-from-request-to-response-part-1--introduction" target="_blank" rel="external">Rails from Request to Response 系列</a>；个人选择了自己感兴趣的部分进行翻译，需要阅读原文的同学请戳前面的链接。</em></p>
<h2 id="第一部分-导言（Introduction）"><a href="#第一部分-导言（Introduction）" class="headerlink" title="第一部分 导言（Introduction）"></a>第一部分 导言（Introduction）</h2><h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><p>在讲 Rails 调用栈之前，先简单介绍一下不同服务器应用的作用，其中并不会涉及到各个服务器应用（比如<code>Thin</code>和<code>Unicorn</code>或<code>Nginx</code>）的细节，因为文章的重点是讲 Rails 端的一些东西。</p>
<p>这里举一个<code>Unicorn</code>的简单例子，管窥整个 Rails 应用。</p>
<h3 id="Unicorn架构"><a href="#Unicorn架构" class="headerlink" title="Unicorn架构"></a>Unicorn架构</h3><p><code>Unicorn</code>是一个实现了<a href="http://rack.github.io/" target="_blank" rel="external">Rack</a>接口的服务器应用，通过多个<code>Worker</code>并行处理请求（request）。启动时，主进程会将 Rails App 代码加在到内存中，随后以加载进来内存为原料进行复制，生成一定数量的<code>Worker</code>，并对他们进行监控和信号捕获（比如被用作关闭和重启的QUIT，TERM，USR1信号等等）。这些<code>Worker</code>负责处理的一个个真实的Web请求（request）。</p>
<p>下图是<code>Unicorn</code>的架构（<a href="https://github.com/blog/517-unicorn" target="_blank" rel="external">这幅图片</a>来自Github一篇很棒的文章）：<br><img src="http://7xjra1.com1.z0.glb.clouddn.com/unicorn_architecture.png" alt="Unicorn Architecture"></p>
<p>这些<code>Worker</code>从共享的<code>Socket</code>中读取HTTP请求（request），并将它们发给Rails应用。随后得到响应（response），写回到共享的<code>Socket</code>中。这个过程中的大部份都发生在Unicorn<code>HttpServer</code>类的<code>#process_client</code>方法中，下面是相关部分的代码：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># unicorn/lib/unicorn/http_server.rb</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_client</span><span class="params">(client)</span></span></div><div class="line">  status, headers, body = @app.call(env = @request.read(client))</div><div class="line"></div><div class="line">  ...</div><div class="line"></div><div class="line">  http_response_write(client, status, headers, body,</div><div class="line">                      @request.response_start_sent)</div><div class="line"></div><div class="line">  client.shutdown</div><div class="line">  client.close</div><div class="line"><span class="keyword">rescue</span> =&gt; e</div><div class="line">  handle_error(client, e)</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></p>
<p><em>其中省略了一些关于<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.1.1" target="_blank" rel="external">HTTP 100</a>状态处理和<a href="http://blog.phusion.nl/2013/01/23/the-new-rack-socket-hijacking-api/" target="_blank" rel="external">Rack socket hijacking</a>相关的代码，感兴趣的话可以阅读<a href="https://github.com/defunkt/unicorn/blob/728b2c70cda7787a80303c6fa2c2530dcb490c90/lib/unicorn/http_server.rb#L570" target="_blank" rel="external">完整版本</a>。</em></p>
<p>我们可以看到，这个方法的核心逻辑相当的简明！</p>
<p>第一行是<a href="https://github.com/rack/rack/blob/master/SPEC" target="_blank" rel="external">Rack specification</a>：Rake App 其实就是一个 Ruby Object，我们只需要为它写一个可以接受 hash 参数<code>env</code>的<code>#call</code>方法，让它的返回<code>[status, headers, body]</code>（译者：还不是很明白<code>Rake</code>是什么鬼的同学可以去看一下这个<a href="http://railscasts-china.com/episodes/the-rails-initialization-process-by-kenshin54" target="_blank" rel="external">视频</a>，亲测好评）。</p>
<p>这个就是<code>Rails</code>，<code>Sinatra</code>，<code>Padrino</code>等那些兼容了Rake接口的框架的核心。回到<code>#process_client</code>方法，可以看到，我们向<code>@app</code>的<code>#call</code>方法传递 env 参数，并在 client 关闭之前，将响应（response）写回。</p>
<p>你没猜错，这个<code>@app</code>就是我们的 Rails 项目，我们来看他的声明：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># blog/config/application.rb</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">module</span> <span class="title">Blog</span></span></div><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Application</span> &lt; Rails::Application</span></div><div class="line">    ...</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></p>
<p>这就是 Rails 调用栈的入口，但是如果你仔细观察，你会发现<code>#call</code>并没有定义在<code>Blog::Application</code>，而是被声明在了父类<code>Rails::Application</code>中。</p>
<p>现在开始，我们需要了解 Rails 应用的继承机制，以及一个请求（request）是如何在 Rails 内部被处理的。</p>
<h3 id="Rails-Application-and-Engines"><a href="#Rails-Application-and-Engines" class="headerlink" title="Rails Application and Engines"></a>Rails Application and Engines</h3><p>我们之前提到，整个 Rails 应用的入口<code>#call</code>被定义在了<code>Rails::Application</code>中，我们通过继承来使用它。这里是它的定义（<a href="https://github.com/rails/rails/blob/0dea33f770305f32ed7476f520f7c1ff17434fdc/railties/lib/rails/application.rb#L139" target="_blank" rel="external">源码</a>）：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># rails/railties/lib/rails/application.rb</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">module</span> <span class="title">Rails</span></span></div><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Application</span> &lt; Engine</span></div><div class="line"></div><div class="line">    <span class="comment"># Implements call according to the Rack API. It simply</span></div><div class="line">    <span class="comment"># dispatches the request to the underlying middleware stack.</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call</span><span class="params">(env)</span></span></div><div class="line">      env[<span class="string">"ORIGINAL_FULLPATH"</span>] = build_original_fullpath(env)</div><div class="line">      env[<span class="string">"ORIGINAL_SCRIPT_NAME"</span>] = env[<span class="string">"SCRIPT_NAME"</span>]</div><div class="line">      <span class="keyword">super</span>(env)</div><div class="line">    <span class="keyword">end</span></div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></p>
<p>这里并没有什么东西，大部分功能通过调用<code>super</code>来执行。如果我们跟着代码看，可以发现<code>Rails::Application</code>类继承于<code>Rails::Engine</code>类。如果你熟悉<a href="http://edgeguides.rubyonrails.org/engines.html" target="_blank" rel="external">Rails engines</a>，你会惊喜地发现，<code>Rails::Application</code>就是一个超级<code>engine</code>!</p>
<p>我们来看看<code>Engine</code>类中的<code>#call</code>方法：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># rails/railties/lib/rails/engine.rb</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">module</span> <span class="title">Rails</span></span></div><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Engine</span> &lt; Railtie</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call</span><span class="params">(env)</span></span></div><div class="line">      env.merge!(env_config)</div><div class="line">      <span class="keyword">if</span> env[<span class="string">'SCRIPT_NAME'</span>]</div><div class="line">        env.merge! <span class="string">"ROUTES_<span class="subst">#&#123;routes.object_id&#125;</span>_SCRIPT_NAME"</span> =&gt; env[<span class="string">'SCRIPT_NAME'</span>].dup</div><div class="line">      <span class="keyword">end</span></div><div class="line">      app.call(env)</div><div class="line">    <span class="keyword">end</span></div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></p>
<p>所以，<code>Engine</code>类继承于<code>Rails::Railtie</code>。通过观察<a href="https://github.com/rails/rails/blob/0dea33f770305f32ed7476f520f7c1ff17434fdc/railties/lib/rails/railtie.rb" target="_blank" rel="external">源码</a>，我们可以发现Railtie是Rails框架的核心，他为<code>initializers</code>，<code>config keys</code>，<code>generators</code>和<code>rake tasks</code>等提供钩子方法。</p>
<p>所有Rails的主要部件（<code>ActionMailer</code>，<code>ActionView</code>，<code>ActionController</code>和<code>ActiveRecord</code>）都是一个<code>Railtie</code>，这也就是为什么你可以随意拆装组合这些部件。</p>
<p>在<code>Engine</code>的<code>#call</code>方法中我们看到了<code>#call</code>的另一个代理方法（delegation），这里的<code>app</code>代表的是什么？在同一个文件中，我们发现了他的定义：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># rails/railties/lib/rails/engine.rb</span></div><div class="line"></div><div class="line"><span class="comment"># Returns the underlying rack application for this engine.</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">app</span></span></div><div class="line">  @app <span class="params">||</span>= <span class="keyword">begin</span></div><div class="line">    config.middleware = config.middleware.merge_into(default_middleware_stack)</div><div class="line">    config.middleware.build(endpoint)</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></p>
<p>现在我们到了一个牛逼的位置。这个engine构造了一个类似Rack application的中间件，并将<code>#call</code>方法代理（delegate）给它，他的终点是我们应用的<code>routes</code>，<code>ActionDispatch::Routing::RouteSet</code>类的一个实例。</p>
<p>Rack middleware可以用来「过滤」请求（request）和响应（response），并且可以将一个请求（request）处理过程分解成多个步骤，并视为一个「管道」进行处理，比如：处理权限认证，缓存等等。</p>
<p>你可以通过执行<code>rake middleware</code>来列出一个应用所使用的全部中间件。这里是我对 Blog 应用执行这条指令所得到的结果：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">$ RAILS_ENV=production rake middleware</div><div class="line">use Rack::Sendfile</div><div class="line">use #<span class="xml"><span class="tag">&lt;<span class="name">ActiveSupport::Cache::Strategy::LocalCache::Middleware:0x007f7ffb206f20</span>&gt;</span></span></div><div class="line">use Rack::Runtime</div><div class="line">use Rack::MethodOverride</div><div class="line">use ActionDispatch::RequestId</div><div class="line">use Rails::Rack::Logger</div><div class="line">use ActionDispatch::ShowExceptions</div><div class="line">use ActionDispatch::DebugExceptions</div><div class="line">use ActionDispatch::RemoteIp</div><div class="line">use ActionDispatch::Callbacks</div><div class="line">use ActiveRecord::ConnectionAdapters::ConnectionManagement</div><div class="line">use ActiveRecord::QueryCache</div><div class="line">use ActionDispatch::Cookies</div><div class="line">use ActionDispatch::Session::CookieStore</div><div class="line">use ActionDispatch::Flash</div><div class="line">use ActionDispatch::ParamsParser</div><div class="line">use Rack::Head</div><div class="line">use Rack::ConditionalGet</div><div class="line">use Rack::ETag</div><div class="line">run Blog::Application.routes</div></pre></td></tr></table></figure></p>
<p>其中的大部分都不会讲，因为没有必要去了解全部这些中间件，即使一个请求（request），在到达<code>Blog::Application.routes</code>之前，会途径列表中从上到下所有的中间件。</p>
<p>到这里，我们已经完成了<code>App server / Rails application stack</code>的导言部分的介绍，接下来会着重介绍<code>Rails routing / dispatch stack</code>。</p>
<h3 id="译者总结"><a href="#译者总结" class="headerlink" title="译者总结"></a>译者总结</h3><p>我们可以讲<code>rake app</code>简化地表示为一个函数：</p>
<blockquote>
<p>ƒ: <em>env_set</em> → <em>{ [status, headers, body] }</em></p>
</blockquote>
<p><code>Rails app</code>其实就是若干个函数的嵌套，逐层对输入的<code>env</code>和返回<code>[status, headers, body]</code>进行加工。整个Rails的执行过程，不过如此。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">env</span>(<span class="number">1</span>) → <span class="keyword">env</span>(<span class="number">2</span>) → ... → <span class="keyword">env</span>(i) → ... <span class="keyword">env</span>(n)</div></pre></td></tr></table></figure>
<p>令：<code>s: [status, headers, body]</code><br><figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">s</span><span class="params">(n)</span> → <span class="title">s</span><span class="params">(n-<span class="number">1</span>)</span> → ... → <span class="title">s</span><span class="params">(i)</span> → ... <span class="title">s</span><span class="params">(<span class="number">1</span>)</span></span></div></pre></td></tr></table></figure></p>
<p>看完这篇文章后，终于理解了<a href="http://robbinfan.com/blog/40/ruby-off-rails" target="_blank" rel="external">《Ruby社区应该去Rails化了》</a>中这段话的意思：</p>
<blockquote>
<h3 id="Rails为何不适合做Web-Service"><a href="#Rails为何不适合做Web-Service" class="headerlink" title="Rails为何不适合做Web Service?"></a>Rails为何不适合做Web Service?</h3><p>我发现了一个有意思的现象，最早的一批用Ruby开发Web Service服务的网站，都选择了用Rails开发，而在最近几年又不约而同抛弃Rails重写Web服务框架。当初用Rails的原因很简单，因为产品早期起步，不确定性很高，使用Rails快速开发，可以最大限度节约开发成本和时间。但为何当请求量变大以后，Rails不再适合了呢？</p>
<p>这主要是因为Rails本身是一个full-stack的Web框架，所有的设计目标就是为了开发Website，所以Rails框架封装过于厚重，对于需要更高性能更轻薄的Web Service应用场景来说，暴露出来了很多缺陷：</p>
<h4 id="Rails调用堆栈过深，URL请求处理性能很差"><a href="#Rails调用堆栈过深，URL请求处理性能很差" class="headerlink" title="Rails调用堆栈过深，URL请求处理性能很差"></a>Rails调用堆栈过深，URL请求处理性能很差</h4><p>Rails的设计目标是提供Web开发的 最佳实践 ，所以无论你需要不需要，Rails默认提供了开发Website所有可能的组件，但其中绝大部分你可能一辈子都用不上。例如Rails项目默认添加了20个middleware，但其中10个都是可以去掉的，我们自己的项目当中手工删除了这些middleware：</p>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">config.middleware.delete <span class="string">'Rack::Cache'</span>   <span class="comment"># 整页缓存，用不上</span></div><div class="line">config.middleware.delete <span class="string">'Rack::Lock'</span>    <span class="comment"># 多线程加锁，多进程模式下无意义</span></div><div class="line">config.middleware.delete <span class="string">'Rack::Runtime'</span> <span class="comment"># 记录X-Runtime（方便客户端查看执行时间）</span></div><div class="line">config.middleware.delete <span class="string">'ActionDispatch::RequestId'</span> <span class="comment"># 记录X-Request-Id（方便查看请求在群集中的哪台执行）</span></div><div class="line">config.middleware.delete <span class="string">'ActionDispatch::RemoteIp'</span>  <span class="comment"># IP SpoofAttack</span></div><div class="line">config.middleware.delete <span class="string">'ActionDispatch::Callbacks'</span> <span class="comment"># 在请求前后设置callback</span></div><div class="line">config.middleware.delete <span class="string">'ActionDispatch::Head'</span>      <span class="comment"># 如果是HEAD请求，按照GET请求执行，但是不返回body</span></div><div class="line">config.middleware.delete <span class="string">'Rack::ConditionalGet'</span>      <span class="comment"># HTTP客户端缓存才会使用</span></div><div class="line">config.middleware.delete <span class="string">'Rack::ETag'</span>    <span class="comment"># HTTP客户端缓存才会使用</span></div><div class="line">config.middleware.delete <span class="string">'ActionDispatch::BestStandardsSupport'</span> <span class="comment"># 设置X-UA-Compatible, 在nginx上设置</span></div></pre></td></tr></table></figure>
<blockquote>
<p>其中最夸张的是ActionDispatch::RequestIdmiddleware，只有在大型应用部署在群集环境下进行线上调试才可能用到的功能，有什么必要做成默认的功能呢？ Rails的哲学是：提供最全的功能集给你，如果你用不到，你自己手工一个一个关闭掉 ，但是这样带来的结果就是默认带了太多不必要的冗余功能，造成性能损耗极大。</p>
<p>我们看一个Ruby web框架请求处理性能评测 ，这个评测不访问数据库，也不测试并发性能，主要是测试框架处理URL请求路由，渲染文本，返回结果的处理速度。</p>
<p>Rack: 1570.43 request/s<br>Campig: 1166.16 request/s<br>Sinatra: 912.81 request/s<br>Padrino: 648.68 request/s<br>Rails: 291.27 request/s</p>
<p>Sinatra至少是Rails速度的3倍以上。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 程序开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> rails </tag>
            
            <tag> 学习报告 </tag>
            
            <tag> rake </tag>
            
            <tag> unicorn </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[人类误判心理（2）]]></title>
      <url>/2015/06/25/2015-06-25-charlie-munger-on-the-psychology-of-human-misjudgment-two/</url>
      <content type="html"><![CDATA[<p>作者：查理·芒格</p>
<h3 id="My-second-factor-is-simple-psychological-denial"><a href="#My-second-factor-is-simple-psychological-denial" class="headerlink" title="My second factor is simple psychological denial."></a>My second factor is simple psychological denial.</h3><p><strong>第二条：单纯的心理学上的「否定」</strong></p>
<p><em>This first really hit me between the eyes when a friend of our family had a super-athlete, super-student son who flew off a carrier in the north Atlantic and never came back, and his mother, who was a very sane woman, just never believed that he was dead. And, of course, if you turn on the television, you’ll find the mothers of the most obvious criminals that man could ever diagnose, and they all think their sons are innocent. That’s simple psychological denial. The reality is too painful to bear, so you just distort it until it’s bearable. We all do that to some extent, and it’s a common psychological misjudgment that causes terrible problems.</em></p>
<p>译者：一则小故事，不作具体翻译。了解「精神分析」理论的同学肯定都知道，其实说的就是所谓「心理防卫机制」中的「否认」<sup>[<a href="/self-defense-mechanism#bookmark_denial">1</a>]</sup>。借此机会向大家推荐「心理防卫机制」，希望可以帮助各位更加了解自己。鉴于有些同学无法访问维基百科，将原文<a href="/self-defense-mechanism">复制了一份</a>过来。</p>
]]></content>
      
        <categories>
            
            <category> 读书报告 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 读书报告 </tag>
            
            <tag> 心理 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[人类误判心理（1）]]></title>
      <url>/2015/06/24/2015-06-24-charlie-munger-on-the-psychology-of-human-misjudgment-one/</url>
      <content type="html"><![CDATA[<p>作者：查理·芒格（伯克夏·哈撒韦公司董事会副主席，沃伦·巴菲特的搭档）</p>
<p>本文是作者1995年在哈佛法学院的演讲 <a href="http://www.rbcpa.com/Mungerspeech_june_95.pdf" target="_blank" rel="external">原文链接</a></p>
<h3 id="First-Under-recognition-of-the-power-of-what-psychologists-call-‘reinforcement’-and-economists-call-‘incentives-’"><a href="#First-Under-recognition-of-the-power-of-what-psychologists-call-‘reinforcement’-and-economists-call-‘incentives-’" class="headerlink" title="First: Under-recognition of the power of what psychologists call ‘reinforcement’ and economists call ‘incentives.’"></a>First: Under-recognition of the power of what psychologists call ‘reinforcement’ and economists call ‘incentives.’</h3><p><strong>第一条：低估 心理学家所谓的「强化」 / 经济学家所谓的「激励」的 效果。</strong></p>
<p><em>Well you can say, “Everybody knows that.” Well I think I’ve been in the top 5% of my age cohort all my life in understanding the power of incentives, and all my life I’ve underestimated it. And never a year passes but I get some surprise that pushes my limit a little farther.</em></p>
<p>好吧，你们可能说俺们都知道，然而你们知道的那些并没有什么卵用。老子是俺们这辈人里最了解「激励」的人之一，我这大半辈子还都低估了它有多屌，甚至到现在老子每年还老丁<sup><a href="#bookmark_laoding">[1]</a></sup>能在这玩意上学到新东西，得到新惊喜。</p>
<p><em>One of my favorite cases about the power of incentives is the Federal Express case. The heart and soul of the integrity of the system is that all the packages have to be shifted rapidly in one central location each night. And the system has no integrity if the whole shift can’t be done fast. And Federal Express had one hell of a time getting the thing to work. And they tried moral suasion, they tried everything in the world, and finally somebody got the happy thought that they were paying the night shift by the hour, and that maybe if they paid them by the shift, the system would work better. And lo and behold, that solution worked.</em></p>
<p>俺最喜欢的一个关于「激励」的案例来自联邦快递：对这家公司来说，最重要的就是在每天夜里，包裹必须从一个中央位置被快速地转运出去。而且，如果不足够快的话，这个系统基本上就屁用不顶了。之前该公司就经常被这事折磨得欲仙欲死。他们试着和快递员小哥儿们进行道德教育，和其他所有能想到的奇奇怪怪的方法，然而并没有什么卵用。最后有个人想出了一招，按小时给晚班工人计费。如果给小哥儿们按照轮班发钱，这个系统就更好地运转起来了。你看，这回牛逼了吧。</p>
<p><em>Early in the history of Xerox, Joe Wilson, who was then in the government, had to go back to Xerox because he couldn’t understand how their better, new machine was selling so poorly in relation to their older and inferior machine. Of course when he got there he found out that the commission arrangement with the salesmen gave a tremendous incentive to the inferior machine.</em></p>
<p>在Xerox公司的早期，Joe Wilson这货从他的政府工作上回到Xerox，因为他不知道为啥更牛逼的新机器比渣渣的旧机器卖的还差。妈蛋的，他发现销售人员的佣金制度竟然鼓励他们卖老机器！！！</p>
<p><em>And here at Harvard, in the shadow of B.F. Skinner – there was a man who really was into reinforcement as a powerful thought, and, you know, Skinner’s lost his reputation in a lot of places, but if you were to analyze the entire history of experimental science at Harvard, he’d be in the top handful. His experiments were very ingenious, the results were counterintuitive, and they were important. It is not given to experimental science to do better. What gummed up Skinner’s reputation is that he developed a case of what I always call man-with-a-hammer syndrome: to the man with a hammer, every problem tends to look pretty much like a nail. And Skinner had one of the more extreme cases in the history of Academia, and this syndrome doesn’t exempt bright people. It’s just a man with a hammer…and Skinner is an extreme example of that. And later, as I go down my list, let’s go back and try and figure out why people, like Skinner, get man-with-a-hammer syndrome.</em></p>
<p>在哈尔滨服装学院，有一个叫B.F. Skinner的人，真的视「强化」为一个强有力的思维模式。他在很多地方都名誉受损，不过从哈佛实验科学的历史上看，他算是很屌的了。他的实验很有创造性，实验结果也是反直觉而且重要的。他没能将实验科学做的更好。我经常称将他名誉搞差的原因叫做「王大锤综合征」：对于手里拿着锤子的同学来说，所有问题都像钉子。斯金纳是学术史上的一个极端案例，然而有些明白人也会有这个问题。我先按我本儿上接着说，等会再说为啥大家会得「王大锤综合症」。</p>
<p><em>Incidentally, when I was at the Harvard Law School there was a professor, naturally at Yale, who was derisively discussed at Harvard, and they used to say, “Poor old Blanchard. He thinks declaratory judgments will cure cancer.” And that’s the way Skinner got. And not only that, he was literary, and he scorned opponents who had any different way of thinking or thought anything else was important. This is not a way to make a lasting reputation if the other people turn out to also be doing something important.</em></p>
<p>Btw，我当年在哈佛法学院的时候，有一个教授，他认为宣告判决将治愈癌症，就像Skinner一样。不止如此，他精通文学，经常嘲讽和自己有不同想法的对手。这绝壁不是个维系持久名誉的方法（我擦，这段好难翻译。因为是演讲，可能是作者随便说些有的没的。</p>
<hr>
<p><em><span id="bookmark_laoding">[1]</span> 老丁：经常的意思；例句：王雪冰常说：“我老丁（经常）找老丁（丁麒玮）玩，老丁（丁麒玮）老丁（经常）不出来。”</em></p>
]]></content>
      
        <categories>
            
            <category> 读书报告 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 读书报告 </tag>
            
            <tag> 心理 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[并发模型学习 (4)]]></title>
      <url>/2015/06/22/2015-06-22-seven-concurrency-models-in-seven-weeks-dining-philosophers-problem/</url>
      <content type="html"><![CDATA[<h4 id="哲学家用餐问题（Dining-philosophers-problem）"><a href="#哲学家用餐问题（Dining-philosophers-problem）" class="headerlink" title="哲学家用餐问题（Dining philosophers problem）"></a><a href="https://zh.wikipedia.org/zh-cn/%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98" target="_blank" rel="external">哲学家用餐问题（Dining philosophers problem）</a></h4><p>简单来说：有五个哲学家坐在一张圆桌上，每个人之间放着一只餐叉，这样桌上就有五只餐叉。哲学家只会做两件事，吃饭，或者思考。吃东西的时候，他们就停止思考，思考的时候也停止吃东西。<br><img src="http://7xjra1.com1.z0.glb.clouddn.com/Dining_philosophers.png" alt="来自Wikipedia"></p>
<p>是的，他们每个人都会用到别人用过的餐叉，开不开心。</p>
<p>这个例子一般用来说明死锁问题，经典的场景之一：一名哲学家拿起了自己左手的餐叉，并为其加锁（以免同时被自己左边的哲学家拿到），而后等待自己右手的餐叉锁的释放。</p>
<p>然而，如果五个哲学家同时处于这个状态，就会死锁。</p>
<p>举个栗子：<br><code>Chopstick.java</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chopstick</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>Philosopher.java</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Random;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Philosopher</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</div><div class="line">    <span class="keyword">private</span> Chopstick left, right;</div><div class="line">    <span class="keyword">private</span> Random random;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Philosopher</span><span class="params">(Chopstick left, Chopstick right, <span class="keyword">int</span> id)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.left  = left; <span class="keyword">this</span>.right = right; <span class="keyword">this</span>.id = id;</div><div class="line">        random = <span class="keyword">new</span> Random();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">                Thread.sleep( random.nextInt(<span class="number">1000</span>) );     <span class="comment">// Think for a while</span></div><div class="line">                <span class="keyword">synchronized</span> (left) &#123;                    <span class="comment">// Grab left chopstick</span></div><div class="line">                    System.out.println(<span class="string">"Philosopher#"</span> + id + <span class="string">" take left Chopstick"</span>);</div><div class="line"></div><div class="line">                    <span class="keyword">synchronized</span> (right) &#123;                 <span class="comment">// Grab right chopstick</span></div><div class="line">                        System.out.println(<span class="string">"Philosopher#"</span> + id + <span class="string">" take right Chopstick"</span>);</div><div class="line">                        Thread.sleep( random.nextInt(<span class="number">1000</span>) ); <span class="comment">// Eat for a while</span></div><div class="line">                    &#125;</div><div class="line">                    System.out.println(<span class="string">"Philosopher#"</span> + id + <span class="string">" put right chopsticks"</span>);</div><div class="line">                &#125;</div><div class="line">                System.out.println(<span class="string">"Philosopher#"</span> + id + <span class="string">" put left chopsticks"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>DiningPhilosophers.java</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Random;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiningPhilosophers</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        Philosopher[] philosophers = <span class="keyword">new</span> Philosopher[<span class="number">5</span>];</div><div class="line">        Chopstick[] chopsticks     = <span class="keyword">new</span> Chopstick[<span class="number">5</span>];</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</div><div class="line">            chopsticks[i] = <span class="keyword">new</span> Chopstick();</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</div><div class="line">            philosophers[i] = <span class="keyword">new</span> Philosopher(chopsticks[i], chopsticks[(i + <span class="number">1</span>) % <span class="number">5</span>], i);</div><div class="line">            philosophers[i].start();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</div><div class="line">            philosophers[i].join();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个栗子属于可以锁得死死的那种。</p>
<p>因为全局的多个代码块可能会共同使用一些锁，所以我们可以通过为所有的锁添加一个偏序关系，来避免死锁状态的产生。</p>
<p><code>Philosopher.java</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Philosopher</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</div><div class="line">    <span class="keyword">private</span> Chopstick first, secound;</div><div class="line">    <span class="keyword">private</span> Random random;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Philosopher</span><span class="params">(Chopstick left, Chopstick right, <span class="keyword">int</span> id)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.id = id;</div><div class="line">        <span class="keyword">if</span> (left.getId() &lt; right.getId()) &#123;</div><div class="line">            <span class="keyword">this</span>.first = left; <span class="keyword">this</span>.second = right;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">this</span>.first = right; <span class="keyword">this</span>.second = left;</div><div class="line">        &#125;</div><div class="line">        random = <span class="keyword">new</span> Random();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">                Thread.sleep(random.nextInt(<span class="number">1000</span>));</div><div class="line">                <span class="keyword">synchronized</span>(first) &#123;</div><div class="line">                    System.out.println(<span class="string">"Philosopher#"</span> + id + <span class="string">" take Chopstick#"</span> + first.getId());</div><div class="line"></div><div class="line">                    <span class="keyword">synchronized</span>(second) &#123;</div><div class="line">                        System.out.println( <span class="string">"Philosopher#"</span> +</div><div class="line">                            id +<span class="string">" take Chopstick#"</span> + second.getId() );</div><div class="line">                        Thread.sleep( random.nextInt(<span class="number">1000</span>) );</div><div class="line">                    &#125;</div><div class="line">                    System.out.println(<span class="string">"Philosopher#"</span> + id + <span class="string">" put Chopstick#"</span> + second.getId());</div><div class="line">                &#125;</div><div class="line">                System.out.println(<span class="string">"Philosopher#"</span> + id + <span class="string">" put Chopstick#"</span> + first.getId());</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="外星方法"><a href="#外星方法" class="headerlink" title="外星方法"></a>外星方法</h4><p>这里我们构造有一个类从一个URL进行下载, 用<code>ProgressListeners</code>监听下载速度<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Downloader</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> InputStream in;</div><div class="line">    <span class="keyword">private</span> OutputStream out;</div><div class="line">    <span class="keyword">private</span> ArrayList&lt;ProgressListener&gt; listeners;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Downloader</span><span class="params">(URL url, String outputFilename)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        in = url.openConnect().getInputSteam();</div><div class="line">        out = <span class="keyword">new</span> FileOutputStream(outputFilename);</div><div class="line">        listeners = <span class="keyword">new</span> ArrayList&lt;ProgressListener&gt;();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addListener</span><span class="params">(ProgressListener listener)</span> </span>&#123;</div><div class="line">        listeners.add(listener);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">removeListener</span><span class="params">(ProgressListener listener)</span> </span>&#123;</div><div class="line">        listeners.remove(listener);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">updateProgress</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (ProgressListener listener: listeners)</div><div class="line">            listener.onProgress(n);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> n = <span class="number">0</span>, total = <span class="number">0</span>;</div><div class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">while</span> ( (n = in.read(buffer)) != -<span class="number">1</span> ) &#123;</div><div class="line">                out.write(buffer, <span class="number">0</span>, n);</div><div class="line">                total += n;</div><div class="line">                updateProgress(total);</div><div class="line">            &#125;</div><div class="line">            out.flush();</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;&#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><em>未完待续</em></p>
]]></content>
      
        <categories>
            
            <category> 读书报告 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 读书报告 </tag>
            
            <tag> 并发 </tag>
            
            <tag> 并行 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[并发模型学习 (3)]]></title>
      <url>/2015/06/21/2015-06-21-seven-concurrency-models-in-seven-weeks-memory-visibility/</url>
      <content type="html"><![CDATA[<h4 id="优化的副作用"><a href="#优化的副作用" class="headerlink" title="优化的副作用"></a>优化的副作用</h4><p><img src="http://7xjra1.com1.z0.glb.clouddn.com/the thinker.jpg" alt="What is the meaning of my life?"></p>
<p>由于没有通读过Ruby源码，无法确定这个Bug是否能用Ruby来复现，先用Java：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Puzzle</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> answerReady = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> answer = <span class="number">0</span>;</div><div class="line">    <span class="keyword">static</span> Thread t1 = <span class="keyword">new</span> Thread() &#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            answer = <span class="number">42</span>;</div><div class="line">            answerReady = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">static</span> Thread t2 = <span class="keyword">new</span> Thread() &#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (answerReady)</div><div class="line">                System.out.println(<span class="string">"The meaning of life is: "</span> + answer);</div><div class="line">            <span class="keyword">else</span></div><div class="line">                System.out.println(<span class="string">"I don't know the answer"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        t1.start(); t2.start();</div><div class="line">        t1.join(); t2.join();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>根据线程执行的时序，这段代码的输出可能是：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">The meaning of life is: 42</div></pre></td></tr></table></figure></p>
<p>或者是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">I don&apos;t know the answer</div></pre></td></tr></table></figure></p>
<p>但是还有一种结果可能是：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">The meaning of life is: 0</div></pre></td></tr></table></figure></p>
<p>这说明了，当<code>answerReady</code>为<code>true</code>时<code>answer</code>可能为0！</p>
<p>就好像第六行和第七行颠倒了执行顺序。但是乱序执行是完全可能发生的：</p>
<ol>
<li>编译器的静态优化可以打乱代码的执行顺序（编译原理）</li>
<li>JVM的动态有话也会打乱代码的执行顺序（JVM）</li>
<li>硬件可以通过乱序执行来优化其性能（计算机体系结构）</li>
</ol>
<p>比乱序执行更糟糕的时，有时一个线程产生的修改可能对另一个线程不可见，</p>
<p>如果讲<code>run()</code>写成：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">while</span> (!answerReady)</div><div class="line">        Thread.sleep(<span class="number">100</span>);</div><div class="line">    System.out.println(<span class="string">"The meaning of life is: "</span> + answer);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>answerReady</code>可能不会变成<code>true</code>代码运行后无法退出。</p>
<p>显然，我们需要一个明确的标准来告诉我们，优化会产生什么副作用影响，这就是<code>Java</code>内存模型(其他语言应该也有类似的东西)。Btw，经过本天才的多次试验，Ruby这边可以复现啦！！！</p>
<p>复现代码：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">require</span> <span class="string">'singleton'</span>  </div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Puzzle</span></span></div><div class="line">  <span class="keyword">include</span> Singleton</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span></span></div><div class="line">    @answer_ready = <span class="literal">false</span></div><div class="line">    @answer       = <span class="number">0</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">thread1</span></span></div><div class="line">    Thread.new <span class="keyword">do</span></div><div class="line">      @answer       = <span class="string">'eat'</span></div><div class="line">      @answer_ready = <span class="literal">true</span></div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">thread2</span></span></div><div class="line">    Thread.new <span class="keyword">do</span></div><div class="line">      meaning_of_life = <span class="string">"The meaning of life is: <span class="subst">#&#123;@answer&#125;</span>"</span></div><div class="line">      no_answer       = <span class="string">"I don't know the answer"</span></div><div class="line">      puts @answer_ready ? meaning_of_life : no_answer</div><div class="line">    <span class="keyword">end</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span></div><div class="line">    [thread1, thread2].each(&amp;<span class="symbol">:join</span>)</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">Puzzle.instance.main</div></pre></td></tr></table></figure></p>
<p>实验过程：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"></div><div class="line"><span class="keyword">while</span> [ <span class="string">"<span class="variable">$result</span>"</span> != <span class="string">"The meaning of life is: 0"</span> ]; <span class="keyword">do</span></div><div class="line">  result=<span class="string">"<span class="variable">$(ruby test.rb)</span>"</span></div><div class="line">  <span class="built_in">echo</span> <span class="variable">$result</span></div><div class="line"><span class="keyword">done</span></div></pre></td></tr></table></figure></p>
<p>实验结果：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">➜  /tmp ruby:(system: ruby 2.1.5p273)</div><div class="line">$ sh test.sh</div><div class="line">The meaning of life is: eat</div><div class="line">The meaning of life is: eat</div><div class="line">I don't know the answer</div><div class="line">The meaning of life is: eat</div><div class="line">I don't know the answer</div><div class="line">I don't know the answer</div><div class="line">The meaning of life is: 0</div></pre></td></tr></table></figure></p>
<h4 id="内存可见性"><a href="#内存可见性" class="headerlink" title="内存可见性"></a>内存可见性</h4><p><code>Java</code>内存模型定义了何时一个线程对内存的修改对另一个线程可见。基本原则是，如果读线程和写线程不进行同步，就不能保证可见性。</p>
<p>除了<code>increment</code>之外，<code>count</code>的<code>getter</code>方法也需要进行同步。否则<code>count</code>方法可能获得一个失效的值：对于前面交互的两个线程，<code>conter</code>在<code>join</code>之后调用因此是线程安全的。但这种设计为其他调用<code>conter</code>的方法埋下了隐患。</p>
<p>所以，「竞态条件」和「内存可见性」都可能让多线程程序运行结果出错。除此之外，还有一类问题：「死锁」。</p>
<h3 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h3><p><em><a href="http://www.infoq.com/cn/articles/java-memory-model-1" target="_blank" rel="external">深入理解Java内存模型系列</a></em><br><em><a href="http://www.domaigne.com/blog/computing/mutex-and-memory-visibility/" target="_blank" rel="external">内存可见性</a></em></p>
]]></content>
      
        <categories>
            
            <category> 读书报告 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 读书报告 </tag>
            
            <tag> 并发 </tag>
            
            <tag> 并行 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[并发模型学习 (2)]]></title>
      <url>/2015/06/20/2015-06-20-seven-concurrency-models-in-seven-weeks-mutex/</url>
      <content type="html"><![CDATA[<h4 id="锁儿"><a href="#锁儿" class="headerlink" title="锁儿"></a>锁儿</h4><p>多个线程共享内存时，避免同时修改同一个部分内存造成的问题，需要用<strong>锁</strong>达到线程互斥的目的。某一时间，至多有一个线程持有锁。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span></span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initialize</span></span></div><div class="line">        @count = <span class="number">0</span></div><div class="line">    <span class="keyword">end</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increment</span></span></div><div class="line">        @count += <span class="number">1</span></div><div class="line">    <span class="keyword">end</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">count</span></span></div><div class="line">        @count</div><div class="line">    <span class="keyword">end</span></div><div class="line"> <span class="keyword">end</span></div><div class="line">counter = Counter.new</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">thread</span><span class="params">(counter)</span></span></div><div class="line">  <span class="number">10_000</span>.times &#123; counter.increment &#125;</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">t1 = Thread.new &#123; thread(counter) &#125;</div><div class="line">t2 = Thread.new &#123; thread(counter) &#125;</div><div class="line"></div><div class="line">[t1, t2].each(&amp;<span class="symbol">:join</span>)</div><div class="line">puts counter.count</div></pre></td></tr></table></figure></p>
<p>执行结果<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">➜  /private/tmp ruby:(system: jruby 1.7.19)</div><div class="line">$ ruby test.rb</div><div class="line">13779</div><div class="line">➜  /private/tmp ruby:(system: jruby 1.7.19)</div><div class="line">$ ruby test.rb</div><div class="line">16440</div></pre></td></tr></table></figure></p>
<p>这段代码创建了一个<code>counter</code>对象和两个线程，每个线程调用<code>counter.increment</code> 10,000次。这段代码看上去很简单，但很脆弱。</p>
<p>几乎每次运行都将获得不同的结果，产生这个结果的原因是两个线程使用<code>counter.count</code>时发生了<strong>竞态条件</strong>（即代码行为取决于各操作的时序）</p>
<p>我们来看一下Java编译器是如何解释<code>++count</code>的。其字节码：<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">getfield <span class="attr">#2</span> ;<span class="comment">//获取count的值</span></div><div class="line">ico<span class="symbol">nst_1</span>    ;<span class="comment">//设置加数</span></div><div class="line">iadd        ;<span class="comment">//count加设置好的加数</span></div><div class="line">putfield <span class="attr">#2</span> ;<span class="comment">//将更新的值写回count</span></div></pre></td></tr></table></figure></p>
<p>这就是通称的<em>读-改-写</em>模式。</p>
<p>如果两个线程同时调用<code>increment</code>，线程1执行<code>getfield #2</code>，获取值42。在线程1执行其他动作之前，线程2也执行了<code>getfield #2</code>，获得值42。不过，现在两个线程都将获得的值加1，将43写回count中。导致<code>count</code>只被增加了一次。</p>
<p>竞态条件的解决方案：对<code>count</code>进行同步（synchronize）访问。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span></span></div><div class="line">  <span class="keyword">attr_reader</span> <span class="symbol">:count</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span></span></div><div class="line">    @count         = <span class="number">0</span></div><div class="line">    @counter_mutex = Mutex.new</div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">increment</span></span></div><div class="line">    @counter_mutex.synchronize &#123; @count += <span class="number">1</span> &#125;</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">thread</span><span class="params">(counter)</span></span></div><div class="line">  <span class="number">10_000</span>.times &#123; counter.increment &#125;</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">counter = Counter.new</div><div class="line">t1 = Thread.new &#123; thread(counter) &#125;</div><div class="line">t2 = Thread.new &#123; thread(counter) &#125;</div><div class="line"></div><div class="line">[t1, t2].each(&amp;<span class="symbol">:join</span>)</div><div class="line">puts counter.count</div></pre></td></tr></table></figure></p>
<p>执行结果<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">➜  /private/tmp ruby:(system: jruby 1.7.19)</div><div class="line">$ ruby test.rb</div><div class="line">20000</div></pre></td></tr></table></figure></p>
<p>线程进入<code>increment</code>方法时，获得<code>counter_mutex</code>锁，函数返回的时候释放该锁。同一时间最多有一个进程可以执行函数体，其他线程调用方法时将被阻塞，直到锁被释放。</p>
]]></content>
      
        <categories>
            
            <category> 读书报告 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 读书报告 </tag>
            
            <tag> 并发 </tag>
            
            <tag> 并行 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[并发模型学习 (1)]]></title>
      <url>/2015/06/20/2015-06-20-seven-concurrency-models-in-seven-weeks-thread/</url>
      <content type="html"><![CDATA[<h3 id="互斥和内存模型"><a href="#互斥和内存模型" class="headerlink" title="互斥和内存模型"></a>互斥和内存模型</h3><p>互斥：用锁保证某一时间仅有一个线程可以访问数据；<br>可能带来的麻烦：竞态条件和死锁。</p>
<h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><p>并发的基本单元：线程，可以讲线程看做控制流；<br>线程间通信方式：共享内存。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hi</span><span class="params">(name)</span></span></div><div class="line">  puts <span class="string">"Hi <span class="subst">#&#123;name&#125;</span>!"</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hi_to_folks</span><span class="params">(folks)</span></span></div><div class="line">  folks.inject([]) <span class="keyword">do</span> <span class="params">|threads_array, name|</span></div><div class="line">    threads_array &lt;&lt; Thread.new &#123; say_hi(name) &#125;</div><div class="line">  <span class="keyword">end</span>.each(&amp;<span class="symbol">:join</span>)</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line">say_hi_to_folks <span class="string">%w(Larry Jack)</span></div></pre></td></tr></table></figure></p>
<p>执行结果有可能是<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Hi Larry!</div><div class="line">Hi Jack!</div></pre></td></tr></table></figure></p>
<p>或者是<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Hi Jack!</div><div class="line">Hi Larry!</div></pre></td></tr></table></figure></p>
<p>多线程的运行结果依赖于时序，多次运行结果并不稳定。</p>
<p><em>注：原书使用的Java例子中，两个线程分别为主线程和子线程，由于Ruby中没有相对应的让出线程方法<code>Thread.yield()</code>，而在Ruby中相接近的<code>Thread.pass</code>实验效果又很差，故而改由两个子线程举例（那你为啥要用Ruby？ 因为不用编译啊笨蛋，不过用的都是JRuby</em></p>
]]></content>
      
        <categories>
            
            <category> 读书报告 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 读书报告 </tag>
            
            <tag> 并发 </tag>
            
            <tag> 并行 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode: Longest Substring Without Repeating Characters 解题报告]]></title>
      <url>/2015/06/20/2015-06-20-leetcode-longestSubstringWithoutRepeatingCharacters/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="external">题目描述</a>:<br><em>Given a string, find the length of the longest substring without repeating characters. For example, the longest substring without repeating letters for “abcabcbb” is “abc”, which the length is 3. For “bbbbb” the longest substring is “b”, with the length of 1.</em></p>
<hr>
<p>分析：找到最长的不包含相同字母的字串</p>
<p>题解：用一个队列来存储不含相同字母的子串，用一个hash来标记队列中已经使用过的字符。</p>
<ol>
<li>当发现即将入队的字符未被使用过时，入队，并在hash中标记下来；</li>
<li>当发现即将入队的字符已经被使用过时，记下当前队列中字串的长度，取其与历史最大长度之间的最大值作为新的解。之后将队首的字符逐一出队，并在hash中清除标记，直道清除了即将入队的字符为止，最后字符入队。</li>
<li>循环这个过程，直到所有的字符都被处理完成。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</div><div class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">char</span>&gt; current_sub_str;</div><div class="line">        <span class="keyword">int</span> sub_string_max_length = <span class="number">0</span>;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = s.begin() ; it &lt; s.end(); it++) &#123;</div><div class="line">            <span class="keyword">char</span> current_alphabet = *it;</div><div class="line">            </div><div class="line">            <span class="keyword">if</span> (isAlphabetExist(current_alphabet)) &#123;</div><div class="line">                syncMaxValue( sub_string_max_length, current_sub_str.size() );</div><div class="line">                popSubStringUntilAlphabet( current_alphabet, current_sub_str );</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                markAlphabet(current_alphabet);</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            current_sub_str.push(current_alphabet);</div><div class="line">        &#125;</div><div class="line">        syncMaxValue( sub_string_max_length, current_sub_str.size() );</div><div class="line">        <span class="keyword">return</span> sub_string_max_length;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> SIZE_OF_ASCII    = <span class="number">128</span>;</div><div class="line">    <span class="keyword">bool</span> alphabet_flag[SIZE_OF_ASCII] = &#123; <span class="literal">false</span> &#125;;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAlphabetExist</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> alphabet)</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> alphabet_flag[<span class="keyword">int</span>(alphabet)];</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">syncMaxValue</span><span class="params">(<span class="keyword">int</span> &amp;sub_string_max_length, <span class="keyword">const</span> <span class="keyword">size_t</span> current_sub_string_length)</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (current_sub_string_length &gt; sub_string_max_length) &#123;</div><div class="line">            sub_string_max_length = <span class="keyword">int</span>(current_sub_string_length);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">popSubStringUntilAlphabet</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> alphabet, <span class="built_in">queue</span>&lt;<span class="keyword">char</span>&gt; &amp;current_sub_str)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> ( <span class="keyword">char</span> current_alphabet = current_sub_str.front(); current_alphabet != alphabet;</div><div class="line">            alphabet_flag[<span class="keyword">int</span>(current_alphabet)] = <span class="literal">false</span>,</div><div class="line">            current_sub_str.pop(),</div><div class="line">            current_alphabet = current_sub_str.front()</div><div class="line">        );</div><div class="line">        current_sub_str.pop();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">markAlphabet</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> alphabet)</span> </span>&#123;</div><div class="line">        alphabet_flag[<span class="keyword">int</span>(alphabet)] = <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 解题报告 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> hash </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode: Add Two Numbers 解题报告]]></title>
      <url>/2015/06/20/2015-06-20-leetcode-addTwoNumbers/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/add-two-numbers/" target="_blank" rel="external">题目描述</a>:<br><em>You are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</em></p>
<p><em>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</em><br><em>Output: 7 -&gt; 0 -&gt; 8</em></p>
<hr>
<p>分析：对两个链表进行带进位求和，若长度不一致填零</p>
<p>题解：没什么算法，模拟。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></div><div class="line">    <span class="keyword">int</span> val;</div><div class="line">    ListNode *next;</div><div class="line">    ListNode(<span class="keyword">int</span> x) : val(x), next(<span class="literal">NULL</span>) &#123;&#125;</div><div class="line">&#125;;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</div><div class="line">        ListNode *ans_pointer = <span class="literal">NULL</span>, *ans_head = <span class="literal">NULL</span>;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">bool</span> carry_flag = <span class="literal">false</span>;</div><div class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</div><div class="line">            sum = getSum(getNodeVal(l1), getNodeVal(l2), carry_flag);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (ans_pointer) &#123;</div><div class="line">                ans_pointer-&gt;next = <span class="keyword">new</span> ListNode(sum);</div><div class="line">                ans_pointer       = ans_pointer-&gt;next;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                ans_head    = <span class="keyword">new</span> ListNode(sum);</div><div class="line">                ans_pointer = ans_head;</div><div class="line">            &#125;</div><div class="line">            nextPointer(l1);</div><div class="line">            nextPointer(l2);</div><div class="line">            <span class="keyword">if</span> ( !(l1 || l2) ) &#123;</div><div class="line">                <span class="keyword">if</span> (carry_flag) &#123; ans_pointer-&gt;next = <span class="keyword">new</span> ListNode(<span class="number">1</span>); &#125;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> ans_head;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getNodeVal</span><span class="params">(<span class="keyword">const</span> ListNode* <span class="keyword">const</span> node)</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> node ? node-&gt;val : <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> val1, <span class="keyword">const</span> <span class="keyword">int</span> val2, <span class="keyword">bool</span> &amp;carry_flag)</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> sum = val1 + val2 + carry_flag;</div><div class="line">        carry_flag = (sum &gt;= <span class="number">10</span>);</div><div class="line">        <span class="keyword">return</span> sum % <span class="number">10</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPointer</span><span class="params">(ListNode* &amp;node)</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">        node = node ? node-&gt;next : <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 解题报告 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> linked list </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode: Two Sum 解题报告]]></title>
      <url>/2015/06/19/2015-06-19-leetcode-twoSum/</url>
      <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/two-sum/" target="_blank" rel="external">题目描述</a>:<br><em>Given an array of integers, find two numbers such that they add up to a specific target number.</em></p>
<p><em>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.</em></p>
<p><em>You may assume that each input would have exactly one solution.</em></p>
<p><em>Input: numbers={2, 7, 11, 15}, target=9</em><br><em>Output: index1=1, index2=2</em></p>
<hr>
<p>分析：题中要求找到数组<code>number</code>中“和”为<code>target</code>的两个元素对应的索引。</p>
<p>题解：首先构造一个<code>Hash{ value-&gt;idx }</code>，之后遍历每个元素<code>Numbers[i]</code>对应的<code>Target - Numbers[i]</code>是否在<code>Hash Table</code>中，若存在则输出解。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;numbers, <span class="keyword">int</span> target) &#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; num_idx_map;</div><div class="line">        <span class="keyword">auto</span> n = numbers.size();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) num_idx_map[numbers[i]] = i + <span class="number">1</span>;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</div><div class="line">            <span class="keyword">if</span> ( num_idx_map.find(target - numbers[i]) != num_idx_map.end() ) &#123;</div><div class="line">                <span class="keyword">int</span> current_num_idx = i + <span class="number">1</span>;</div><div class="line">                <span class="keyword">int</span> match_num_idx   = num_idx_map[target - numbers[i]];</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (match_num_idx != current_num_idx) <span class="keyword">return</span> &#123; current_num_idx,  match_num_idx &#125;;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 解题报告 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> hash </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo]]></title>
      <url>/2015/06/13/2015-06-13-octopress2hexo/</url>
      <content type="html"><![CDATA[<p>前阵子有幸地参与到一个 Road Map Project 从无到有的开发过程，整个项目做下来，感触很多。随着项目进入收官阶段，可以自由支配的时间渐渐多一些，准备有规律地更新博文。</p>
<p><img src="http://7xjra1.com1.z0.glb.clouddn.com/galaxy_soho_sky.jpg" alt="难得一见的北京蓝"></p>
<p>这次正式从<code>Octopress</code>迁移到<code>Hexo</code>，个人感觉<code>Hexo</code>更加的 Simple Stupid，从Setup到Deploy的过程相当流畅。</p>
<p><del>关于Hexo的部署，国内朋友的最佳实践是同时发布在<code>Github</code>和<code>Gitcafe</code>上，之后通过<code>DNSpod</code>分散国内外的流量，保证访问速度。感兴趣的同学可以去读一下Reference中的两篇文章。</del></p>
<p><del>我个人比较懒，并没有通过DNS来分流，只是单纯地在<code>Github</code>上备份<code>source</code>文件夹，将其软链到<code>Hexo</code>中。然后在<code>Gitcafe</code>上托管<code>Blog Site</code>。</del></p>
<p><lable style="color: red">更新于：2015.6.23</lable><br>现在还是部署回Github，因为Gitcafe常常出现无法访问的情况。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://kuangqi.me/tricks/hexo-optimizations-for-mainland-china/" target="_blank" rel="external">Hexo Landscape主题的字体和JS库优化</a><br><a href="http://colobu.com/2014/10/13/hexo-supports-both-github-and-gitcafe/" target="_blank" rel="external">Hexo 同时支持Github和Gitcafe</a></p>
]]></content>
      
        <categories>
            
            <category> 技术日志 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
            <tag> octopress </tag>
            
            <tag> gitcafe </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[所谓工作经验]]></title>
      <url>/2015/02/02/2015-02-02-team-working/</url>
      <content type="html"><![CDATA[<p>在学校的时候，不理解为什么有些职位，对工作经验有很严苛的要求。因为我并不认为工作经验和技术能力之间存在这什么必然的联系。</p>
<p>不过近些天来开始意识到：<b>工作经验真的不一定和技术能力成正比，但是和团队协作能力基本上是成正比的。</b></p>
<p><img src="http://7xjra1.com1.z0.glb.clouddn.com/yzhu_jyshi_wdzhang.jpg" alt="可爱的Advertising Team同学们"></p>
<p>到公司后，逐渐地参加到商业软件项目的开发中，通过这段时间的观察，发现到对于一个职业的软件工程师，需要具备的能力并不限于算法和工程问题。还要学会换位思考，站在多个角色的角度来看同一个问题，来保证顺畅的沟通。</p>
<p>软件开发的流程中通常包含了：</p>
<ul>
<li>产品经理<ul>
<li>需求分析文档</li>
</ul>
</li>
<li>开发工程师<ul>
<li>技术设计文档, 编码, 时间估算, 代码审查</li>
</ul>
</li>
<li>测试工程师<ul>
<li>用例设计文档, 时间估算, 自动化测试, 本地测试, 集成测试</li>
</ul>
</li>
<li>运维工程师<ul>
<li>部署上线</li>
</ul>
</li>
</ul>
<p>产品经理在做需求文档的时候，一定征求会开发人员的意见，来做出一个可行的产品设计。</p>
<p>工程师在做技术文档设计和时间估算的时候，也会在团队中其他工程师的建议下，调整设计文档和<code>Story Point</code>预估，来保证设计的逻辑正确性以及可实施性。</p>
<p>部署的过程更需要开发工程师和运维工程师完全地理解彼此的需求，才能保证项目上线不出差错。</p>
<p>在每个环节，如果可以<b>理解每个角色对于一个项目的关切是什么</b>，定会催化团队内部的化学作用，提高团队产出的质量。</p>
]]></content>
      
        <categories>
            
            <category> 流程方法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 工作经验 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[Rails] 所谓MVC]]></title>
      <url>/2015/01/19/2015-01-19-rails-mvc/</url>
      <content type="html"><![CDATA[<p>使用<code>MVC</code>的Web开发框架有很多，比如<code>PHP</code>的<code>Zend</code>，<code>Python</code>的<code>Django</code>和<code>Golang</code>的<code>Beego</code>。这篇文章主要介绍一下<code>MVC</code>的基本概念。</p>
<h2 id="何为MVC"><a href="#何为MVC" class="headerlink" title="何为MVC"></a>何为MVC</h2><p>为了明确一个<code>Web Application</code>中各个部分的职责，我们人为规定三个层级：控制器（Controller），模型（Model）和视图（View），这是一种设计上的解耦。</p>
<p>为了直观地解释这三个层级的概念，我们假设这它们分别对应代码层面的三个类：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooModel</span></span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooView</span></span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooController</span></span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<h4 id="调度器（Controller）-–-完整的request生命周期"><a href="#调度器（Controller）-–-完整的request生命周期" class="headerlink" title="调度器（Controller） – 完整的request生命周期"></a>调度器（Controller） – 完整的request生命周期</h4><p>我们可以简单的理解为：用户在浏览器上输入的每个合法的URL，都将被映射到Controller类上的一个实例方法。该实例方法是一次<code>request</code>的<strong>入口</strong>，负责调度程序的各个部分，返回<code>web response</code>给浏览器。</p>
<p>所谓入口，指的是一次访问的<b>整个生命周期，都随着这个方法的开始而开始，结束而结束。</b>从这个角度来看，我们完全可以不使用模型和视图，就能完成一个Web应用。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Rails中URL和实例方法的映射关系在routes.rb中设置</span></div><div class="line"><span class="comment"># 比如 '/index' =&gt; Controller#index 可以规定:</span></div><div class="line"><span class="comment">#   当用户在browser中输入"http://yoursiteurl.com/index"时</span></div><div class="line"><span class="comment">#   执行Controller类的index方法</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooController</span></span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">index</span></span></div><div class="line">    @counter = @counter ? @counter + <span class="number">1</span> : <span class="number">0</span> </div><div class="line"></div><div class="line">    render <span class="symbol">html:</span> <span class="string">"&lt;p&gt;你是该网站的第<span class="subst">#&#123;@counter&#125;</span>名访客&lt;/p&gt;"</span>.html_safe</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<h4 id="模型（Model）-–-数据持久化存储"><a href="#模型（Model）-–-数据持久化存储" class="headerlink" title="模型（Model） – 数据持久化存储"></a>模型（Model） – 数据持久化存储</h4><p>我们可以看到，在一次request结束后，Controller实例方法中分配的内存会被回收，无法再次被使用。为了能够将Controller处理过程中的数据在今后继续使用，我们需要对这部分数据进行持久化存储。</p>
<p>所以我们期望有一个类，他的所有变量都永远不会消失。同时，我们还希望它可以提取对数据操作的逻辑（如例中的counter计数），方便今后复用。我们将它叫做模型（Model），至于它如何做到所有的变量永不消失，我们回头再讲。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooModel</span></span></div><div class="line">  <span class="comment"># ...</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">counter</span></span></div><div class="line">    @counter = @counter ? @counter + <span class="number">1</span> : <span class="number">0</span> </div><div class="line">    save <span class="comment"># 持久化存储，具体实现细节在后面的文章会讲</span></div><div class="line"></div><div class="line">    @counter</div><div class="line">  <span class="keyword">end</span></div><div class="line">  <span class="comment"># ...</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooController</span></span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">index</span></span></div><div class="line">    model = FooModel.new</div><div class="line">    render <span class="symbol">html:</span> <span class="string">"&lt;p&gt;你是该网站的第<span class="subst">#&#123;model.counter&#125;</span>名访客&lt;/p&gt;"</span>.html_safe</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<h4 id="视图（View）-–-页面展示"><a href="#视图（View）-–-页面展示" class="headerlink" title="视图（View） – 页面展示"></a>视图（View） – 页面展示</h4><p>在上面的两个例子中都出现了类似<code>render html: xxx</code>之类的代码。如果我们不想在Controller中出现HTML代码，可以把它放在View层。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooModel</span></span></div><div class="line">  <span class="comment"># ...</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">counter</span></span></div><div class="line">    @counter = @counter ? @counter + <span class="number">1</span> : <span class="number">0</span> </div><div class="line">    save <span class="comment"># 持久化存储，具体实现细节在后面的文章会讲</span></div><div class="line"></div><div class="line">    @counter</div><div class="line">  <span class="keyword">end</span></div><div class="line">  <span class="comment"># ...</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooView</span></span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(counter)</span></span></div><div class="line">    <span class="string">"&lt;p&gt;你是该网站的第<span class="subst">#&#123;counter&#125;</span>名访客&lt;/p&gt;"</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooController</span></span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">index</span></span></div><div class="line">    model = FooModel.new</div><div class="line">    view  = FooView.new</div><div class="line"></div><div class="line">    render <span class="symbol">html:</span> view.index(model.counter).html_safe</div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<h3 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h3><p><em>1. 调度器（Controller）对于一个程序来说是必须存在的，它负责得到输入，返回输出</em><br><em>2. 我们用模型（Model）这个概念来<strong>抽象</strong>调度器（Controller）中，关于<strong>数据存取、逻辑运算</strong>相关的代码，以便独立地维护它们。</em><br><em>3. 我们用视图（View）这个概念来<strong>抽象</strong>调度器（Controller）中，关于<strong>数据展示格式</strong>相关的代码，以便独立地维护它们。</em></p>
]]></content>
      
        <categories>
            
            <category> 程序开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> rails </tag>
            
            <tag> 学习报告 </tag>
            
            <tag> MVC </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[Rails] 学习报告]]></title>
      <url>/2015/01/16/2015-01-16-rails-for-newbee/</url>
      <content type="html"><![CDATA[<p>在阅读这个系列文章之前，希望读者对于网络开发有一些了解，最好能够先完成以下课程的学习： </p>
<blockquote>
<p><a href="http://v.163.com/special/opencourse/cs50.html" target="_blank" rel="external">哈佛大学公开课：计算机科学cs50</a> (Web部分)<br><a href="http://v.163.com/special/opencourse/buildingdynamicwebsites.html" target="_blank" rel="external">哈佛大学公开课：构建动态网站</a></p>
</blockquote>
<p>其实，终究Rails只是一个框架，他只是一种设计思想的实体化的产物。你不能说傻学怎么用这个框架，所以你不能一上来就直接学各种Rails的feature。</p>
<p>最好的学习方法，是学习这个框架的设计思路。因为如果这样，即使之后<strong>你们不再使用rails，你也可以用ruby开发或者组装出另一套新的框架。甚至如果你们不再使用ruby，你也可以用其他语言，写出基于另一个语言的开发框架。这些都超越了语言和框架的本身，是大家共性的东西，是精髓。</strong>而且就我个人来讲，这个概念可以更广义地应用到更多的方面，此处不多深入，有机会时会写一篇文章。</p>
<blockquote>
<p>[Rails] <a href="/2015/01/19/2015-01-19-rails-mvc/">所谓MVC</a><br>[Rails] <a href="/2015/06/26/2015-06-26-rails-dispatcher/">从Request到Response</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 程序开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> rails </tag>
            
            <tag> 学习报告 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Homebrew]]></title>
      <url>/2015/01/09/2015-01-09-donot-sudo-brew/</url>
      <content type="html"><![CDATA[<p>近些天来一直受到一个问题的困扰，在执行<code>activemq start</code>后，能够看到进程已经启动，然而根本没有什么卵用，完全连不上<code>localhost:8161/admin/</code>。改成<code>sudo activemq start</code>，问题就解决了。</p>
<p>今天终于发现了问题的原因：当初我在用<code>brew</code>安装<code>activemq</code>的时候就是用的是：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo brew install activemq</div></pre></td></tr></table></figure></p>
<p>而正确的安装方式是：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ brew install activemq</div></pre></td></tr></table></figure></p>
<p>解决方案：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ brew reinstall activemq</div></pre></td></tr></table></figure></p>
<p>如果再这么做的话，这个世界，就清静了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ brew reinstall `brew list`</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 开发工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> activemq </tag>
            
            <tag> homebrew </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[关于 Everkeyword]]></title>
      <url>/2015/01/04/2015-01-04-always-wirting/</url>
      <content type="html"><![CDATA[<h3 id="为什么叫Everkeyword"><a href="#为什么叫Everkeyword" class="headerlink" title="为什么叫Everkeyword"></a>为什么叫Everkeyword</h3><p>学生时期，比较爱想，有过一个创业的Idea。当时就觉得Everkeyword这个名字非常适合想象中的“产品”。从那时候开始，就一直想把这个域名注册下来。</p>
<h3 id="Everkeyword是做什么的"><a href="#Everkeyword是做什么的" class="headerlink" title="Everkeyword是做什么的"></a>Everkeyword是做什么的</h3><p>Everkeyword现在是我的个人技术博客，而不再是那个产品。我会在上面分享一些技术方面的心得体会。</p>
]]></content>
      
        <categories>
            
            <category> 技术日志 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Ruby]]></title>
      <url>/2014/09/07/2014-09-07-metaprogramming-ruby/</url>
      <content type="html"><![CDATA[<blockquote>
<p>Bill is a good mentor.</p>
</blockquote>
<p>长达三个月的培训过程，过得非常的舒心。在中后段期间，每天下午都能抽出一段时间，读一读《Ruby元编程》。</p>
<p>读过这本书的人，应该都会爱上Ruby这门语言，并且理解它为何要设计成这个样子。书中的描写十分生动，有时甚至会让人觉得，自己真的和Bill工作在一起，每天在他的身上学习新的知识。找时间写一篇这本书的读书报告。</p>
<blockquote>
<p>目录<br>第一部分 Ruby元编程</p>
<ul>
<li>对象模型</li>
<li>方法</li>
<li>代码块</li>
<li>类定义</li>
<li>编写代码的代码</li>
</ul>
<p>第二部分 “Rails中的元编程”</p>
<ul>
<li>ActiveRecord的设计</li>
<li>深入ActiveRecord</li>
<li>安全元编程 </li>
</ul>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 读书报告 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 读书报告 </tag>
            
            <tag> ruby </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[VIM]]></title>
      <url>/2014/08/02/2014-08-02-wirte-rails-by-using-vim/</url>
      <content type="html"><![CDATA[<p>看<a href="http://Railscasts-china.com" target="_blank" rel="external">RailsCast China</a>的时候，收集了一些常用来写Ruby on Rails的Vim插件:</p>
<ul>
<li><a href="http://www.vim.org/scripts/script.php?script_id=3025" target="_blank" rel="external">commandT</a><br>功能: 与Sublime的commandT快捷键类似，可以实现当前项目文件查找</li>
<li><p><a href="http://kien.github.com/ctrlp.vim/" target="_blank" rel="external">CtrlP</a><br>功能: 实现文件的查找，并快速切换；<br>“CommandT”和”CtrlP”的功能基本一致，顾名思义，通过快捷键”command+T”和”Ctrl+P”，呼叫插件。</p>
</li>
<li><p><a href="http://www.vim.org/scripts/script.php?script_id=1567" target="_blank" rel="external">Rails.vim</a><br>常用功能:<br>“:Rfind/:1R/:find”: 可以用来查找目录中的文件<br>“:Rfunctionaltest”: 跳转到单元测试<br>“:RController”: 跳转到Controller<br>“:RVfunctionaltest”: (横屏分屏)打开单元测试<br>“gf”: 代码上线文相关跳转<br>详见文档</p>
</li>
<li><p><a href="http://www.vim.org/scripts/script.php?script_id=2540" target="_blank" rel="external">snipMate</a><br>功能: 输入简写展开<br>例: ‘bt’+Tab-&gt;‘belongs_to’, ‘hm’+Tab-‘has_many’, ‘rp’+Tab-&gt;“render :partial =&gt; ‘item’”, …<br>ruby.snippets文件中有各个简写展开形式的记录，也可以通过改写这个文件，自定义展开形式</p>
</li>
<li><p><a href="https://github.com/mileszs/ack.vim" target="_blank" rel="external">ack.vim</a><br>功能: 根据文件内容查找文件，并切换文件<br>例: “:Ack ‘pattern’”</p>
</li>
<li><p><a href="http://www.vim.org/scripts/script.php?script_id=1658" target="_blank" rel="external">The NERD tree</a><br>功能: 显示文件目录;</p>
</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference:"></a>Reference:</h2><p>Rails with Vim : <a href="http://Railscasts-china.com/episodes/Rails-with-vim" target="_blank" rel="external">http://Railscasts-china.com/episodes/Rails-with-vim</a></p>
]]></content>
      
        <categories>
            
            <category> 开发工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> vim </tag>
            
            <tag> rails </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++ PRIMER PLUS (11)]]></title>
      <url>/2012/03/10/2012-03-10-cpp-primer-plus-11/</url>
      <content type="html"><![CDATA[<h2 id="第11章-使用类"><a href="#第11章-使用类" class="headerlink" title="第11章 使用类"></a>第11章 使用类</h2><h3 id="11-1-操作符重载"><a href="#11-1-操作符重载" class="headerlink" title="11.1 操作符重载"></a>11.1 操作符重载</h3><p>操作符重载时一种形式的C++多态，函数原型：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">Type_name <span class="keyword">operator</span> <span class="title">op</span> <span class="params">(argument-<span class="built_in">list</span>)</span></span>;</div></pre></td></tr></table></figure></p>
<p><code>Type_name operator op</code>相当于函数名，<code>(argument-list)</code>相当于参数列表，<code>Type_name</code>相当于返回值，只是在调用的时候可省去函数后的括号和函数名中<code>operator</code>（不省也行，如<code>strsum = str1.operator+(str2);</code>）</p>
<p>第一个参数通过<code>this</code>指针隐式传递</p>
<h3 id="11-3-友元简介"><a href="#11-3-友元简介" class="headerlink" title="11.3 友元简介"></a>11.3 友元简介</h3><p>在左侧的操作数不是调用对象时，可使用非成员函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">A = <span class="number">2.75</span> * B; <span class="comment">// can not correspond to a mumber fuction</span></div><div class="line">A = <span class="keyword">operator</span>*(<span class="number">2.75</span>, B); <span class="comment">// can correspond to a mumber fuction</span></div></pre></td></tr></table></figure></p>
<p>函数原型如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Time <span class="keyword">operator</span>* (<span class="keyword">double</span> m, <span class="keyword">const</span> Time &amp;t);</div></pre></td></tr></table></figure></p>
<p>但这引发了一个新问题，非成员函数不能访问类的私有数据。<br>创建友元函数要先将其原型放在类声明中，并在前面加上关键字<code>friend</code>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">friend</span> Time <span class="keyword">operator</span>* (<span class="keyword">double</span> m, <span class="keyword">const</span> Time &amp;t);</div></pre></td></tr></table></figure></p>
<p>友元函数不能使用成员操作符调用，但与成员函数访问权限相同<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Time <span class="keyword">operator</span>* (<span class="keyword">double</span> m, <span class="keyword">const</span> Time &amp;t)</div><div class="line">&#123;</div><div class="line">       <span class="keyword">return</span> t * m;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>重载<code>&lt;&lt;</code>操作符</p>
<p>第一种版本，定义友元函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> <span class="keyword">operator</span>&lt;&lt; (ostream &amp;os, <span class="keyword">const</span> Time &amp;t)</div><div class="line">&#123;</div><div class="line">       os &lt;&lt; t.hours &lt;&lt; <span class="string">"hours, "</span> &lt;&lt; t.minutes &lt;&lt; <span class="string">"minutes"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>os</code>可以暂时理解为<code>cout</code>的别名</p>
<h3 id="11-5-再谈重载：矢量类"><a href="#11-5-再谈重载：矢量类" class="headerlink" title="11.5 再谈重载：矢量类"></a>11.5 再谈重载：矢量类</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">shove.<span class="built_in">set</span>(<span class="number">100</span>, <span class="number">300</span>); <span class="comment">//直接设置</span></div><div class="line">shove = Vector(<span class="number">100</span>, <span class="number">300</span>) <span class="comment">// Vector为类名，此方法使用构造函数创建一个临时对象，让后赋给shove</span></div></pre></td></tr></table></figure>
<p>一元负号操作符<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Vector Vector::<span class="keyword">operator</span>-() <span class="keyword">const</span></div><div class="line">&#123;</div><div class="line">       <span class="keyword">return</span> Vector(-x, -y);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="11-6-类的自动转换和强制类型转换"><a href="#11-6-类的自动转换和强制类型转换" class="headerlink" title="11.6 类的自动转换和强制类型转换"></a>11.6 类的自动转换和强制类型转换</h3><p>只接受一个参数的构造函数如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Stonewt (<span class="keyword">double</span> lbs);</div></pre></td></tr></table></figure></p>
<p>可隐式转换<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Stonewt mycat;</div><div class="line">mycat = <span class="number">19.6</span>; <span class="comment">//程序调用Stonewt(double)来创建临时对象，然后赋值</span></div><div class="line"><span class="comment">// 但这种类型并不总合乎需要，可用explicit来关闭这种特性</span></div><div class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Stonewt</span><span class="params">(<span class="keyword">double</span> lbs)</span></span>;</div></pre></td></tr></table></figure></p>
<p>这将关闭上例的隐式转换，但仍然允许显式强制转换<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Stonewt myCat；</div><div class="line">myCat = Stonewt(<span class="number">19.6</span>);</div><div class="line">myCat = (Stonewt) <span class="number">19.6</span>;</div></pre></td></tr></table></figure></p>
<p>现在研究如何将对象转换为数字<br>转换函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">operator</span> <span class="title">typeName</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure></p>
<p>注意：</p>
<ul>
<li>转换函数必须是类方法</li>
<li>转换函数不能指定返回类型</li>
<li>转换函数不能有参数</li>
</ul>
<p>例如，转换为double的函数原型<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure></p>
<p>如果该类值定义了一个转换函数，则可以直接用<code>cout</code>输出该类(<code>&lt;&lt;</code>未重载。否则编译器将认为语句有二义性而拒绝它，只能在前增加强制类型转换<br>转换函数也有其优缺点，如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> ar[<span class="number">20</span>];</div><div class="line">……</div><div class="line"><span class="function">Stonewt <span class="title">temp</span><span class="params">(<span class="number">14</span>, <span class="number">4</span>)</span></span>;</div><div class="line"><span class="keyword">int</span> Temp = <span class="number">1</span>;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; ar[temp];</div></pre></td></tr></table></figure></p>
<p>这种误用对象为索引之类的错误不会被编译器发现，而转换函数又不能用<code>explicit</code>来关闭隐式转换<br>解决方法是定义一个功能相同的非转换函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> Stonest::Stone_to_Int()</div><div class="line">&#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">int</span>(pounds + <span class="number">0</span>,<span class="number">5</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在<code>main</code>上面定义的全局对象的构造函数会先于<code>main</code>运行</p>
<p><em>第十一章结束</em></p>
]]></content>
      
        <categories>
            
            <category> 读书报告 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer plus </tag>
            
            <tag> 读书报告 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++ PRIMER PLUS (10)]]></title>
      <url>/2012/03/10/2012-03-10-cpp-primer-plus-10/</url>
      <content type="html"><![CDATA[<h2 id="第10章-对象和类"><a href="#第10章-对象和类" class="headerlink" title="第10章 对象和类"></a>第10章 对象和类</h2><h3 id="OOP特性："><a href="#OOP特性：" class="headerlink" title="OOP特性："></a>OOP特性：</h3><ul>
<li>抽象</li>
<li>封装和数据隐藏</li>
<li>多态</li>
<li>继承</li>
<li>代码的可重用性</li>
</ul>
<h3 id="10-1-过程性编程和面向对象编程"><a href="#10-1-过程性编程和面向对象编程" class="headerlink" title="10.1 过程性编程和面向对象编程"></a>10.1 过程性编程和面向对象编程</h3><h3 id="10-2-抽象和类"><a href="#10-2-抽象和类" class="headerlink" title="10.2 抽象和类"></a>10.2 抽象和类</h3><h3 id="10-3-类的构造函数和析构函数"><a href="#10-3-类的构造函数和析构函数" class="headerlink" title="10.3 类的构造函数和析构函数"></a>10.3 类的构造函数和析构函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> stock::show() <span class="keyword">const</span> <span class="comment">//promises note change invoking object</span></div></pre></td></tr></table></figure>
<p>这种方法声明和定义的类函数成为<code>const</code>成员函数，只要类方法不修改调用对象，就应该将其声明为<code>const</code>。因为形如<code>show()</code>的方法没有形参，不能用<code>const</code>引用或<code>const</code>指针来避免修改对象。</p>
<p>在当前类的方法中<code>*this</code>可作为当前类的别名进行修改或访问。</p>
<h3 id="10-7-类的作用域"><a href="#10-7-类的作用域" class="headerlink" title="10.7 类的作用域"></a>10.7 类的作用域</h3><p>在类中定义常量的方式——使用关键字<code>static</code>:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">stock</span></span></div><div class="line">&#123;</div><div class="line">       <span class="keyword">private</span>:</div><div class="line">       <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> len = <span class="number">30</span>;</div><div class="line">       …</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><em>第十章结束</em></p>
]]></content>
      
        <categories>
            
            <category> 读书报告 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer plus </tag>
            
            <tag> 读书报告 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++ PRIMER PLUS (9)]]></title>
      <url>/2012/02/21/2012-02-21-cpp-primer-plus-9/</url>
      <content type="html"><![CDATA[<h2 id="第九章-内存模型和名称空间"><a href="#第九章-内存模型和名称空间" class="headerlink" title="第九章 内存模型和名称空间"></a>第九章 内存模型和名称空间</h2><h3 id="9-1-单独编译"><a href="#9-1-单独编译" class="headerlink" title="9.1 单独编译"></a>9.1 单独编译</h3><p>头文件：包含结结构声明和使用这些结构的函数原型。</p>
<p>源代码文件：包含与机构有关的函数代码。</p>
<p>源代码文件：包含调用与结构相关的函数的代码。</p>
<p>头文件中包含的内容：</p>
<ul>
<li>函数原型</li>
<li>使用<code>#define</code>或<code>const</code>定义的符号常量</li>
<li>结构声明</li>
<li>类声明    </li>
<li>模板声明</li>
<li>内联函数</li>
<li>多个库的连接：在连接编译模块时，请确保所有对象文件或库都是有同一个编译器生成的。因为C++标准允许每个编译器设计人员以他认为合适的方式实现名称修饰。</li>
</ul>
<h3 id="9-2-存储持续性、作用于和连接性"><a href="#9-2-存储持续性、作用于和连接性" class="headerlink" title="9.2 存储持续性、作用于和连接性"></a>9.2 存储持续性、作用于和连接性</h3><p>自动变量：在函数中声明的变量<br>静态变量：在函数定义外定义和使用<code>static</code>定义的变量<br>动态变量：用<code>new</code>和<code>delete</code>分配和删除的变量</p>
<h4 id="9-2-1-作用域和连接"><a href="#9-2-1-作用域和连接" class="headerlink" title="9.2.1 作用域和连接"></a>9.2.1 作用域和连接</h4><p>作用域为局部的变量只在定义它的代码块（<code>{</code>,<code>}</code>之间）可用。<br>在函数原型作用域中使用的名称只在包含参数列表的括号内可用。</p>
<h4 id="9-2-2-自动存储持续性"><a href="#9-2-2-自动存储持续性" class="headerlink" title="9.2.2 自动存储持续性"></a>9.2.2 自动存储持续性</h4><p>局部变量名和全局变量名相同时，将暂时隐藏之前的全集定义。<br>关键字auto用于定义默认状态向为自动的变量，有时可用来向读者澄清代码的含义，比如程序中他一创建了一个自动变量，它将覆盖全局定义。<br>编译器使用堆栈来管理自动内存。<br>用register关键字来声明局部变量将提醒编译器通过使用CPU寄存器来处理该变量，但编译器并不一定会满足上述请求。</p>
<p>注意：寄存器变量没有内存地址。</p>
<h4 id="9-2-3-静态持续变量"><a href="#9-2-3-静态持续变量" class="headerlink" title="9.2.3 静态持续变量"></a>9.2.3 静态持续变量</h4><p>如果没有显式初始化，编译器将把它设置为0。</p>
<p>只能使用常量表达式来初始化静态变量：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> x; <span class="comment">// x set to 0</span></div><div class="line"><span class="keyword">int</span> y = <span class="number">49</span>; <span class="comment">//49 is a constant expression</span></div><div class="line"><span class="keyword">int</span> z = <span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>) + <span class="number">1</span>;<span class="comment">// also a constant expression</span></div><div class="line"><span class="keyword">int</span> m = <span class="number">2</span> * z; <span class="comment">// incalud, z not a constant</span></div></pre></td></tr></table></figure></p>
<p>通常情况下应使用局部变量，在需要知晓时才传递数据。</p>
<p>对于外部链接性变量，有且只有一个文件包含了该变量的外部定义。其他文件要使用该变量，必须在引用声明中使用关键字<code>extern</code>。</p>
<p>如果文件定义了一个静态外部变量，其名称与另一个文件中声明的常规外部变量相同，则在该文件中，静态变量将隐藏常规外部变量。</p>
<p>当吧作用域解析操作符<code>::</code>放在变量名称前面是，表示使用变量的全局版本。</p>
<p>将<code>static</code>限定符用于全局变量时，该变量的链接性将为内部的，只能在其所属文件中使用。<br>如果初始化了静态局部变量，则程序只在启动时进行一次初始化。</p>
<p>通常，编译器去假设未被修改的值在两次使用时之间不会发生变化，将该值缓存，以优化。<code>Volatile</code>声明相当于告诉编译器，不要进行这种优化（因为硬件可能修改变量）。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span></span></div><div class="line">&#123;</div><div class="line">       <span class="keyword">char</span> name[<span class="number">30</span>];</div><div class="line">       <span class="keyword">mutable</span> <span class="keyword">int</span> accesses;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">const</span> data veep = &#123;<span class="string">"Claybourne Clodde"</span>, <span class="number">0</span>,…&#125;;</div><div class="line"><span class="built_in">strcpy</span>(veep.name, <span class="string">"Joye Joux"</span>); <span class="comment">//not allowed</span></div><div class="line">veep.accesses++; <span class="comment">//allowed</span></div></pre></td></tr></table></figure></p>
<p><code>veep</code>的<code>const</code>限定符禁止程序修改<code>veep</code>的成员，但<code>accesses</code>成员的<code>mutable</code>说明符是的<code>accesses</code>不受这种限制。<br><code>const</code>全局变量的链接性为内部的，因此可以在所有文件中使用相同的声明<br>若希望某个常量的链接性为外部的，必须在所有使用该变量的文件中使用<code>extern</code>关键字来声明它<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> states = <span class="number">50</span>; <span class="comment">// external linkage</span></div></pre></td></tr></table></figure></p>
<p>可以再函数原型中使用关键字<code>extern</code>来指出函数是在另一个文件中定义的，不过这是可选的。<br>还可以使用关键字<code>static</code>将函数的链接性设置为内部的，必须同时在原型和函数定义中使用该关键字。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">private</span> <span class="params">(<span class="keyword">double</span> x)</span></span>;</div><div class="line">…</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">private</span> <span class="params">(<span class="keyword">double</span> x)</span></span>;</div><div class="line">&#123;</div><div class="line">…</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果定义了一个和库函数同名的函数，编译器将采用程序员定义的版本。</p>
<h4 id="9-2-6-语言链接性-如：函数名翻译"><a href="#9-2-6-语言链接性-如：函数名翻译" class="headerlink" title="9.2.6 语言链接性 (如：函数名翻译)"></a>9.2.6 语言链接性 (如：函数名翻译)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">void</span> <span class="title">spiff</span><span class="params">(<span class="keyword">int</span>)</span></span>;</div><div class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">spoff</span><span class="params">(<span class="keyword">int</span>)</span></span>;</div><div class="line"><span class="keyword">extern</span> <span class="string">"C++"</span> <span class="function"><span class="keyword">void</span> <span class="title">spaff</span><span class="params">(<span class="keyword">int</span>)</span></span>;</div></pre></td></tr></table></figure>
<p>第一个原型使用C语言链接性，第二个原型默认使用C++链接性，第三个显式使用C++链接性。</p>
<h4 id="9-2-7-存储方案和动态分配"><a href="#9-2-7-存储方案和动态分配" class="headerlink" title="9.2.7 存储方案和动态分配"></a>9.2.7 存储方案和动态分配</h4><p>在函数中用来跟踪动态内存的自动和静态指针变量遵循之前的存储方案，在函数结束时被释放，而new分配的内存会一直保留在内存当中，如果将指针的链接性声明为外部的，则在文件中后面的函数都可以使用它。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">float</span> *p = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">20</span>];</div></pre></td></tr></table></figure></p>
<h3 id="9-3-布局new操作符"><a href="#9-3-布局new操作符" class="headerlink" title="9.3 布局new操作符"></a>9.3 布局new操作符</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> buffer1[<span class="number">50</span>];</div><div class="line"><span class="keyword">char</span> buffer2[<span class="number">500</span>];</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chaff</span></span></div><div class="line">&#123;</div><div class="line">       <span class="keyword">char</span> dross[<span class="number">20</span>];</div><div class="line">       <span class="keyword">int</span> slag;</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">       …</div><div class="line">       p2 = <span class="keyword">new</span> (buffer1) chaff;</div><div class="line">       p4 = <span class="keyword">new</span> (buffer2) <span class="keyword">int</span> [<span class="number">20</span>];</div><div class="line">       …</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码中，从<code>buffer1</code>中分配空间给结构<code>chaff</code>，从<code>buffer2</code>中分配空间给一个<code>int</code>数组。</p>
]]></content>
      
        <categories>
            
            <category> 读书报告 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer plus </tag>
            
            <tag> 读书报告 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++ PRIMER PLUS (8)]]></title>
      <url>/2012/02/21/2012-02-21-cpp-primer-plus-8/</url>
      <content type="html"><![CDATA[<h2 id="第八章-函数探幽"><a href="#第八章-函数探幽" class="headerlink" title="第八章 函数探幽"></a>第八章 函数探幽</h2><h3 id="8-1-C-内联函数"><a href="#8-1-C-内联函数" class="headerlink" title="8.1 C++内联函数"></a>8.1 C++内联函数</h3><p>内联函数的编译代码与其他程序代码「内联」起来了。也就是说编译器将使用相应的函数代码替换函数调用。对于内联代码，程序无需跳到另一个位置处执行代码，然后再跳回来。因此，内联函数的运行速度比常规函数快，但代价是需要占用更多的内存，因为编译后的可执行程序由一组机器指令组成。运行程序时，操作系统将这些指令载入到计算机内存中。</p>
<p>内联与宏：宏不能按值传递，比如将(i++)传给宏，只能进行文本复制，而不会计算其值。 </p>
<h3 id="8-2-引用变量"><a href="#8-2-引用变量" class="headerlink" title="8.2 引用变量"></a>8.2 引用变量</h3><p>引用是已定义变量的别名，他们指向相同的值和内存单元。<br>声明引用时，必须将其初始化。 </p>
<h4 id="8-2-2-将引用用作函数参数"><a href="#8-2-2-将引用用作函数参数" class="headerlink" title="8.2.2 将引用用作函数参数"></a>8.2.2 将引用用作函数参数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">( <span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span></span>;</div><div class="line">swap(wallet1, wallet2);</div></pre></td></tr></table></figure>
<p>相当于将形参<code>a</code>和<code>b</code>分别初始化为<code>wallet1</code>和<code>wallet2</code>。参数传递给接受引用参数时，实参应是一个变量，而非计算表达式，毕竟引用函数是实参的一个别名。</p>
<p>仅当参数为<code>const</code>时，C++才允许这样做，C++将生成临时变量。 </p>
<h4 id="8-2-4-将引用用于结构"><a href="#8-2-4-将引用用于结构" class="headerlink" title="8.2.4 将引用用于结构"></a>8.2.4 将引用用于结构</h4><p>通常，返回机制将被复制到一个临时返回存储单元中，随后调用程序将访问该区域，然而，如果返回值是一个引用，则返回内容将直接复制到变量中，这样做效率更高。</p>
<p>返回引用时最重要的一点是应避免返回当函数终止时不再存在的内存单元引用。为了避免这种问题，可以返回一个作为参数传递给函数的引用或用new来分配新的存储空间。 </p>
<p>为何将const用于引用返回类型？</p>
<p>返回引用为const意味着你不能使用返回的引用直接修改它指向的结构，如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">const</span> xxx &amp; <span class="title">function</span><span class="params">(xxx&amp; temp)</span></span></div><div class="line">&#123;<span class="keyword">return</span> temp;&#125;</div><div class="line">xxx ori;</div><div class="line">xxx aim;</div><div class="line">function(aim) = ori;<span class="comment">// 不允许，但若无const，则可以</span></div></pre></td></tr></table></figure></p>
<h4 id="8-2-5-将引用用于类对象"><a href="#8-2-5-将引用用于类对象" class="headerlink" title="8.2.5 将引用用于类对象"></a>8.2.5 将引用用于类对象</h4><h4 id="8-2-6-对象，继承和引用"><a href="#8-2-6-对象，继承和引用" class="headerlink" title="8.2.6 对象，继承和引用"></a>8.2.6 对象，继承和引用</h4><p>派生类继承了基类的方法。基类引用可以指向派生类对象，而无需强制类型转换，所以可以定义一个接受基类引用作为参数的函数，调用函数是，可以将基类对象作为参数，也可以将派生类对象作为参数。 </p>
<h4 id="8-2-7-何时使用引用参数"><a href="#8-2-7-何时使用引用参数" class="headerlink" title="8.2.7 何时使用引用参数"></a>8.2.7 何时使用引用参数</h4><p>传递值而不做修改的函数：</p>
<ol>
<li>程序员能够修改调用函数中的数据对象</li>
<li>通过传递引用而不是整个数据对象可以提高程序运行速度</li>
<li>如果数据对象很小，如内置数据类型或小型结构，则按值传递</li>
<li>如果对象时数组，则使用指针，因为这是唯一选择，并将指针声明为指向<code>const</code>的指针</li>
<li>如果数据对象是较大的结构，则使用<code>const</code>指针或<code>const</code>引用，以提高程序效率。这样可以节省复制结构所需的时间和空间</li>
<li>如果数据对象是类对象，则使用<code>const</code>引用 </li>
</ol>
<p>修改调用函数中数据的函数：</p>
<ol>
<li>如果数据对象是内置数据类型，则使用指针</li>
<li>如果数据对象是数组，则只能使用指针</li>
<li>如果数据对象是结构，则使用引用或指针</li>
<li>如果数据对象是类对象，则使用引用 </li>
</ol>
<h3 id="8-3-默认参数"><a href="#8-3-默认参数" class="headerlink" title="8.3 默认参数"></a>8.3 默认参数</h3><p>默认参数必须通过函数原型设置。 </p>
<h3 id="8-4-函数重载"><a href="#8-4-函数重载" class="headerlink" title="8.4 函数重载"></a>8.4 函数重载</h3><p>在函数中，是特征标，而不是函数类型使得可以对函数进行重载。 </p>
<h3 id="8-5-函数模板"><a href="#8-5-函数模板" class="headerlink" title="8.5 函数模板"></a>8.5 函数模板</h3><h4 id="8-5-2-显示具体化"><a href="#8-5-2-显示具体化" class="headerlink" title="8.5.2 显示具体化"></a>8.5.2 显示具体化</h4><p>当编译器找到与函数调用匹配的具体化定义时，将使用该定义，而不再寻找模板<br>显示具体化原型：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">template&lt;&gt; void swap&lt;job&gt;(job&amp;, job&amp;);<span class="regexp">//job</span>是一个数据类型</div></pre></td></tr></table></figure></p>
<p>1.第三代具体化<br>对于给定的函数名，可以有非模板函数、模板函数和显示具体化模板函数以及他们的重载版本；显示具体化的原型和定义应以<code>template&lt;&gt;</code>打头，并通过名称来指出类型；</p>
<p>具体化将覆盖常规模板，而非模板函数将覆盖具体化和常规模板。</p>
<p>旧版的C++编译器在具体化时，函数前不加<code>template&lt;&gt;</code>，如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> swap&lt;job&gt;(job&amp;, job&amp;);</div></pre></td></tr></table></figure></p>
<h4 id="8-5-3-实例化和具体化"><a href="#8-5-3-实例化和具体化" class="headerlink" title="8.5.3 实例化和具体化"></a>8.5.3 实例化和具体化</h4><ul>
<li>编译器使用模板为特定类型生成函数定义时，得到的是模板实例。</li>
<li>显示具体化句法是，声明所需种类——用<code>&lt;&gt;</code>符号指示类型，并在声明前加上关键字<code>template</code>； </li>
<li>显示实例化与显示具体化的区别在于，显示具体化的意思是”不要使用模板来生成函数定义，而用独立的、<br>专门的函数定义为显示地为特定类型的函数定义。而且显示具体化声明在关键字<code>template</code>后包含<code>&lt;&gt;</code>，而显示具体化没有。 </li>
</ul>
<h4 id="8-5-4-编译器选择使用哪个函数版本"><a href="#8-5-4-编译器选择使用哪个函数版本" class="headerlink" title="8.5.4 编译器选择使用哪个函数版本"></a>8.5.4 编译器选择使用哪个函数版本</h4><p>第一步：创建候选函数列表，其中包含与被调用函数的名称相同的模板函数<br>第二步：使用候选函数列表创建可行函数列表。</p>
<ul>
<li>这些都是参数数目正确的函数，为此有一个隐式转换序列，其中包括实参类型与相应的形参类型完全匹配的情况。例如，使用一个<code>float</code>参数的函数调用可以将该参数转换为<code>double</code>，从而与<code>double</code>形参匹配，而模板可以为<code>float</code>声场一个实例。</li>
</ul>
<p>第三步：确定是否有最佳的可行函数。如果有，则使用它，否则该函数调用出错 </p>
<p>从最佳到最差的顺序如下：</p>
<ol>
<li>完全匹配，但常规函数优先于模板</li>
<li>提升转换(例如，<code>char</code>和<code>shorts</code>自动转换为<code>int</code>，<code>float</code>自动转换为<code>double</code>)</li>
<li>标准转换(例如，<code>int</code>转换为<code>char</code>，<code>long</code>转换为<code>double</code>)</li>
<li>用户定义的转换，如类声明中定义的转换。 </li>
</ol>
<h3 id="附："><a href="#附：" class="headerlink" title="附："></a>附：</h3><blockquote>
<p>Page.255：完全匹配和最佳匹配<br>Page.257：有多个参数的函数</p>
</blockquote>
<p><em>第八章结束</em></p>
]]></content>
      
        <categories>
            
            <category> 读书报告 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer plus </tag>
            
            <tag> 读书报告 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++ PRIMER PLUS (7)]]></title>
      <url>/2012/01/29/2012-01-29-cpp-primer-plus-7/</url>
      <content type="html"><![CDATA[<h2 id="第七章-函数——C-编程模块"><a href="#第七章-函数——C-编程模块" class="headerlink" title="第七章 函数——C++编程模块"></a>第七章 函数——C++编程模块</h2><h4 id="7-1-1-定义函数"><a href="#7-1-1-定义函数" class="headerlink" title="7.1.1 定义函数"></a>7.1.1 定义函数</h4><p>如果声明的返回类型是<code>double</code>，而函数返回一个<code>int</code>表达式，则该<code>int</code>值将被强制转换为<code>double</code>类型 </p>
<h4 id="7-1-2-函数原型和函数调用"><a href="#7-1-2-函数原型和函数调用" class="headerlink" title="7.1.2 函数原型和函数调用"></a>7.1.2 函数原型和函数调用</h4><p>句法：函数原型不要求提供变量名，有类型列表就足够了，如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span>)</span></span>;</div></pre></td></tr></table></figure></p>
<p>原型用的变量名相当于占位符，因此不必与函数定义中的变量名相同<br>功能：原型确保以下几点：</p>
<ul>
<li>编译器正确处理函数的返回值</li>
<li>编译器检查使用的参数数目是否正确</li>
<li>编译器检查使用的参数数目是够正确</li>
</ul>
<p>通常，原型自动将被传递的参数强制转换为期望的类型。当较大的类型被自动转换为较小的类型时，有些编译器将发出警告，指出这可能会丢失数据 </p>
<h3 id="7-2-函数参数和按值传递"><a href="#7-2-函数参数和按值传递" class="headerlink" title="7.2 函数参数和按值传递"></a>7.2 函数参数和按值传递</h3><h3 id="7-3-函数和数组"><a href="#7-3-函数和数组" class="headerlink" title="7.3 函数和数组"></a>7.3 函数和数组</h3><p>在C++中，当且仅当用于函数头或函数原型中时，<code>int *arr</code>和<code>int arr[]</code>的含义才是相同的。<br>当指针指向数组的第一个元素时，本书中使用数组表示法；而当指针指向一个独立的值时，使用指针表示法。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">arr[i] == *(ar + i);</div><div class="line">&amp;arr[i] == ar+(i * 指向类型的长度)</div></pre></td></tr></table></figure></p>
<p>原数组和参数数组指向同一个地址。但<code>sizeof(原数组)</code>为数组大小，而<code>sizeof(参数数组)</code>则为指针变量的大小，这就是必须显示传递数组长度，而不能再函数中使用<code>sizeof()</code>计算的原因；<br>记住：为将数组类型和元素属相告诉数组处理函数，请通过两个不同的参数来传递它们。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">fillArray</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> size)</span></span>; <span class="comment">//prototype</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">fillArray</span><span class="params">(<span class="keyword">int</span> arr[size])</span></span>; <span class="comment">//bad prototype</span></div></pre></td></tr></table></figure></p>
<h4 id="7-3-5-指针和const"><a href="#7-3-5-指针和const" class="headerlink" title="7.3.5 指针和const"></a>7.3.5 指针和const</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> age = <span class="number">39</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> *pt  = &amp;age;</div></pre></td></tr></table></figure>
<p>该声明指出，<code>pt</code>指向一个<code>const int(这里是39)</code>，因此不能使用pt来修改这个值，换句话来说，<code>*pt</code>的值为<code>const</code>，不能被修改：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">*pt += <span class="number">1</span>; <span class="comment">//INVALID</span></div><div class="line"><span class="built_in">cin</span> &gt;&gt; *pt; <span class="comment">//INVALID</span></div></pre></td></tr></table></figure></p>
<p>尽可能使用<code>const</code>，将指针参数声明为指向常量数据的指针有两条理由</p>
<ol>
<li>这样可以避免无意间修改数据而导致变成错误;</li>
<li>使用<code>const</code>使得函数能够处理<code>const</code>和非<code>const</code>实参，否则只能接受非<code>const</code>数据。</li>
</ol>
<p>第二种使用<code>const</code>的方式使得无法修改指针的值：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> sloth = <span class="number">3</span>;</div><div class="line"><span class="keyword">int</span> * <span class="keyword">const</span> finger = &amp;sloth;</div></pre></td></tr></table></figure></p>
<p>这种声明格式使得<code>finger</code>只能指向<code>sloth</code>，但允许使用<code>finger</code>来修改<code>sloth</code>的值。 </p>
<h3 id="7-4-函数和二维数组"><a href="#7-4-函数和二维数组" class="headerlink" title="7.4 函数和二维数组"></a>7.4 函数和二维数组</h3><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int sum(int (*arr)[常数], int size);</div><div class="line">int sum(int arr[][常数], int size);</div></pre></td></tr></table></figure>
<p>处理固定行数，未知列数的二维数据；<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ar2[r][c] == *(*(ar2 + r) + c);</div></pre></td></tr></table></figure></p>
<h3 id="7-9-函数指针"><a href="#7-9-函数指针" class="headerlink" title="7.9 函数指针"></a>7.9 函数指针</h3><p>与数据项相似，函数也有地址。函数地址是存储机器语言代码的内存的开始地址。 </p>
<h4 id="7-9-1-函数指针的基础知识"><a href="#7-9-1-函数指针的基础知识" class="headerlink" title="7.9.1 函数指针的基础知识"></a>7.9.1 函数指针的基础知识</h4><ol>
<li><p>获取函数的地址<br>只要使用函数名即可。也就是说，如果<code>think()</code>是一个函数，则<code>think</code>就是该函数的地址。</p>
</li>
<li><p>声明函数指针</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">double</span> <span class="title">pam</span><span class="params">(<span class="keyword">int</span>)</span></span>;</div><div class="line"><span class="keyword">double</span> (*pf)(<span class="keyword">int</span>);</div></pre></td></tr></table></figure>
<p> 使用该函数指针的函数的原型</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void estimate(int lines, double(*pf)(int));</div></pre></td></tr></table></figure>
</li>
<li><p>使用指针来调用函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">double</span> x = (*pf)(<span class="number">5</span>);</div></pre></td></tr></table></figure>
</li>
</ol>
<p>注：C++中<code>(*pf)(5)</code>和<code>pf(5)</code>是等价的。 </p>
<p><em>第七章结束</em></p>
]]></content>
      
        <categories>
            
            <category> 读书报告 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> c++ </tag>
            
            <tag> c++ primer plus </tag>
            
            <tag> 读书报告 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
